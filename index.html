<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/03/2018-2-1-windows创建只有拓展名的文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/03/2018-2-1-windows创建只有拓展名的文件/" class="post-title-link" itemprop="url">2018-2-1-windows创建只有拓展名的文件</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-03 21:16:16" itemprop="dateCreated datePublished" datetime="2019-04-03T21:16:16+08:00">2019-04-03</time>
            

            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/04/03/2018-2-1-windows创建只有拓展名的文件/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/04/03/2018-2-1-windows创建只有拓展名的文件/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/24/2019-3-24-BAND-VIP资源导览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/24/2019-3-24-BAND-VIP资源导览/" class="post-title-link" itemprop="url">BAND-VIP资源导览</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-24 02:30:09" itemprop="dateCreated datePublished" datetime="2019-03-24T02:30:09+08:00">2019-03-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 12:51:55" itemprop="dateModified" datetime="2019-04-03T12:51:55+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/BAND-VIP/" itemprop="url" rel="index"><span itemprop="name">BAND-VIP</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/24/2019-3-24-BAND-VIP资源导览/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/24/2019-3-24-BAND-VIP资源导览/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>A positive attitude causes a chain reaction of positive thoughts,events and outcomes.</p>
</blockquote>
<p>Hi，各位同学们，大家好，欢迎踏上数据分析的<del>不归路</del>列车~在发车之前，有几点需要给大家强调一下：</p>
<p><strong>课程和项目</strong>：</p>
<ul>
<li>课程以项目为导向，学习曲线十分平缓，我也是从一个小白一步步走过来的，所以请大家一定要对自己有<strong>信心</strong></li>
<li>我们把整体的一个大任务（课程毕业）拆分成了四个子任务（项目），在每个子任务中又拆分成了<strong>知识学习、项目提交和修改、总结沉淀</strong>三个部分，在这三个部分之中，大家还可以自行再进行切分，如此将一个大难题拆分成若干个小问题，逐个击破，十分轻松</li>
<li>对于项目，大家一定要重视！切不可抄袭，一定要<strong>对自己负责任</strong></li>
</ul>
<p><strong>如何提问</strong>：</p>
<p>在课程学习中难免会遇到问题，请按照以下流程进行问题提问：</p>
<ul>
<li><p><strong>课程知识问题</strong>：</p>
<ul>
<li>先自行查找问题答案，参考：谷歌/必应搜索、<a href="http://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>、<a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a>、<a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/SQL.Cookbook(%E4%B8%AD%E6%96%87%E7%89%88" target="_blank" rel="noopener">SQLCookbook</a>.pdf)</li>
<li>若问题未解决，请将<strong>问题</strong>及其<strong>所在课程章节</strong>发送至微信群，并@讲师即可</li>
</ul>
</li>
<li><p><strong>非课程知识问题</strong>：</p>
<p>比如账号登录、课程加载等问题，请详细描述问题，反馈给助教即可</p>
</li>
</ul>
<p>该说的也说了个差不多，那么，请大家<del>系好安全带</del>做好<strong>觉悟</strong>：</p>
<ul>
<li>工作可能会很忙，但是每天至少要抽出一个小时来坚持学习，否则一日废，日日废</li>
<li>准备好一个笔记本或者有道云笔记、EverNote这种电子笔记本，用来记录学习笔记/问题</li>
<li>自律，自律，自律！自律才能让你更自由！</li>
</ul>
<p>准备发车！</p>
<h1 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h1><p>课程安排中包括每周学习的进度，以及优达日的时间&amp;内容，为了能有最佳的学习体验，大家尽量按照这个进度表来哦~</p>
<p><img src="https://s2.ax1x.com/2019/03/24/AYJhM6.png" alt="AYJhM6.png"></p>
<h1 id="每周导学"><a href="#每周导学" class="headerlink" title="每周导学"></a>每周导学</h1><p>每周导学部分，是对上面课程安排的细化，会对每周的课程内容进行难重点分析，分享相关学习资料链接等等~</p>
<blockquote>
<p>感谢优达学城优秀讲师吕华老师提供的导学文档，大家可以忽略文档的时间。</p>
</blockquote>
<ul>
<li><a href="https://docs.qq.com/doc/DYnNhb3RteHJtY1Jo" target="_blank" rel="noopener">第二周-可视化与信息有效表达</a></li>
<li><a href="https://docs.qq.com/doc/DYkFRbm5zTWZheU12" target="_blank" rel="noopener">第三周-描述统计学</a><ul>
<li>想了解更多？可以戳<a href="http://www.capallen.top/dand-vip/2018/09/13/%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">统计学基础</a></li>
</ul>
</li>
<li><a href="https://docs.qq.com/doc/DYnVoVnB0ZU5Vc0Vh" target="_blank" rel="noopener">第四周-电子表格（Excel）</a></li>
<li><a href="https://docs.qq.com/doc/DYnZ1bnBxZk5rQUVx" target="_blank" rel="noopener">第五周-分析问卷数据</a></li>
<li><a href>第六周-</a></li>
<li><a href>第七周-</a></li>
<li><a href>第八周-</a></li>
<li><a href>第九周-</a></li>
</ul>
<h1 id="优达日录屏"><a href="#优达日录屏" class="headerlink" title="优达日录屏"></a>优达日录屏</h1><p>我会把每次优达日的视频录制好，方便大家回顾~</p>
<ul>
<li><a href>专题分享-可视化与信息的有效表达</a></li>
</ul>
<h1 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h1><ul>
<li><a href="http://www.makeovermonday.co.uk/" target="_blank" rel="noopener">Makeover Monday</a>，每周会分享一个专题，提供数据及可视化建议。</li>
<li><a href="https://color.adobe.com/zh/create/color-wheel/?base=2&amp;rule=Analogous&amp;selected=0&amp;name=%E6%88%91%E7%9A%84%20Color%20%E4%B8%BB%E9%A1%8C&amp;mode=rgb&amp;rgbvalues=0.5981896185787718,1,0,0.91,0.6057919966858591,0.04550000000000004,1,0,0,0.28694819805649985,0.04550000000000004,0.91,0.050000000000000044,0.9546307733516641,1&amp;swatchOrder=0,1,2,3,4" target="_blank" rel="noopener">Adobe Color</a>，Adobe官方提供的色彩和谐搭配方案，支持自定义。</li>
<li><a href="http://open.163.com/special/Khan/khstatistics.html" target="_blank" rel="noopener">可汗学院公开课：统计学</a>，更基础一些的统计学课程。</li>
<li><p><a href="https://sqlzoo.net/wiki/SQL_Tutorial/zh" target="_blank" rel="noopener">一站式SQL学练指南</a>，可以去这里锻炼SQL代码。</p>
</li>
<li><p><a href="https://share.weiyun.com/5NPySZC" target="_blank" rel="noopener">腾讯微云’’图书馆’’</a>，搜集的一些数据分析相关书籍。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/12/2018-12-12-第二轮第三周-Numpy&Pandas基础 - 副本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/12/2018-12-12-第二轮第三周-Numpy&Pandas基础 - 副本/" class="post-title-link" itemprop="url">第二轮第三周-Numpy&Pandas基础</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-12 02:30:09" itemprop="dateCreated datePublished" datetime="2018-12-12T02:30:09+08:00">2018-12-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 17:05:49" itemprop="dateModified" datetime="2019-04-03T17:05:49+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DAND-VIP/" itemprop="url" rel="index"><span itemprop="name">DAND-VIP</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/12/12/2018-12-12-第二轮第三周-Numpy&Pandas基础 - 副本/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/12/12/2018-12-12-第二轮第三周-Numpy&Pandas基础 - 副本/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>A positive attitude causes a chain reaction of positive thoughts,events and outcomes.</p>
</blockquote>
<p>Hi，同学们，上周我们主要对python的基础知识进行了学习，从完全不懂到写出第一段代码，从畏惧发怵到解决第一个代码问题，大家已经从小白迈出了python入门的第一步！你们都是最棒的！那请继续保持着这样的学习动力，趁热打铁，继续我们的课程吧！</p>
<p>本周开始，我们就进入到了<strong>项目二(P2)阶段的第二周</strong>，需要针对数据分析来学习两个重要的第三方库<strong>Numpy</strong>和<strong>Pandas</strong>，它们是python实现科学计算和数据处理的重要库，在以后的数据分析路上会经常用到，所以一定要掌握，并且还要熟练！</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>学习重点</th>
<th>对应课程</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1周</td>
<td>Python基础内容</td>
<td>数据类型和运算符、控制流、函数、脚本编写</td>
</tr>
<tr>
<td><strong>第2周</strong></td>
<td><strong>Python数据处理内容</strong></td>
<td><strong>Numpy &amp; Pandas</strong></td>
</tr>
<tr>
<td>第3周</td>
<td>完成项目</td>
<td>项目：探索美国共享单车数据</td>
</tr>
<tr>
<td>第4周</td>
<td>项目修改与通过</td>
<td>修改项目、查缺补漏、休息调整</td>
</tr>
</tbody>
</table>
<p>对于非小白同学来说，本阶段内容不是很难，希望你们能在三周内完成并通过项目；  </p>
<p>对于小白来说，本阶段可能是个挑战，请一定要<strong>保持自信</strong>，请一定要坚持<strong>学习和总结</strong>，如果遇到任何<strong>课程问题</strong>请参照如下顺序进行解决：</p>
<ul>
<li>先自行查找问题答案（注意提取关键词），参考：谷歌/百度搜索、<a href="http://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>、<a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a>、<a href="https://stackoverflow.com/" target="_blank" rel="noopener">stack<strong>overflow</strong></a>、<a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/Python%20for%20Data%20Analysis%2C%202nd%20Edition.pdf" target="_blank" rel="noopener"><strong>Python for Data Analysis, 2nd Edition</strong> </a>、<a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Python Cookbook</a></li>
<li>若问题未解决，请将<strong>问题</strong>及其<strong>所在课程章节</strong>发送至微信群，并@助教即可</li>
</ul>
<p>饭要一口一口吃，路要一步一步走，大家不要被任务吓到，跟着导学一步一步来，肯定没问题哒！那我们开始吧！</p>
<blockquote>
<p><strong>注：</strong>本着<strong>按需知情</strong>原则，所涉及的知识点都是在数据分析过程中必须的、常用的，而不是最全面的，想要更丰富，那就需要你们课下再进一步的学习和探索！</p>
</blockquote>
<h1 id="本周目标"><a href="#本周目标" class="headerlink" title="本周目标"></a>本周目标</h1><ul>
<li>学完课程<strong>Numpy&amp;Pandas</strong>。</li>
<li>（可选）项目环境准备。</li>
</ul>
<h1 id="知识清单"><a href="#知识清单" class="headerlink" title="知识清单"></a>知识清单</h1><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><h3 id="NumPy-简介"><a href="#NumPy-简介" class="headerlink" title="NumPy 简介"></a>NumPy 简介</h3><p><strong>NumPy</strong> 是 <em>Numerical Python</em> 的简称，它是 Python 中的科学计算基本软件包。NumPy 为 Python 提供了大量数学库，使我们能够高效地进行数字计算。更多可点击<a href="http://www.numpy.org/" target="_blank" rel="noopener">Numpy官网</a>查看。</p>
<p><strong>关于Numpy需要知道的几点：</strong></p>
<ul>
<li>NumPy 数组在创建时有<strong>固定的大小</strong>，不同于Python列表（可以<strong>动态增长</strong>）。<strong>更改ndarray的大小将创建一个新的数组并删除原始数据</strong>。</li>
<li>NumPy 数组中的元素都需要具有<strong>相同的数据类型</strong>，因此在存储器中将具有相同的大小。数组的元素如果也是数组（可以是 Python 的原生 array，也可以是 ndarray）的情况下，则构成了多维数组。</li>
<li>NumPy 数组便于对大量数据进行高级数学和其他类型的操作。<strong>通常，这样的操作比使用Python的内置序列可能更有效和更少的代码执行</strong>。</li>
</ul>
<p>所以，Numpy 的核心是<code>ndarray</code>对象，这个对象封装了同质数据类型的n维数组。起名 <code>ndarray</code> 的原因就是因为是 <code>n-dimension-array</code> 的简写。接下来本节所有的课程都是围绕着ndarray来讲的，理论知识较少，代码量较多，所以大家在学习的时候，多自己动动手，尝试自己去运行一下代码。</p>
<h3 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h3><blockquote>
<p>课程中所说的，创建一个秩为2的ndarray，实际上指的是创建一个2维的ndarray，并不是矩阵的秩。</p>
</blockquote>
<ul>
<li>由python list创建</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 1维数组</span></span><br><span class="line">print(type(a), a.shape, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt; <span class="params">(<span class="number">3</span>,)</span> 1 2 3</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">a[0] = 5                 # 重新赋值</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[<span class="number">5</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])   <span class="comment"># 2维数组</span></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">print(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>由numpy内置函数创建</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">2</span>))  <span class="comment"># 创建2x2的全0数组</span></span><br><span class="line">print(a)</span><br><span class="line">[[ <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>]]</span><br><span class="line"></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))   <span class="comment"># 创建1x2的全1数组</span></span><br><span class="line">print(b)</span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>]]</span><br><span class="line"></span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">7</span>) <span class="comment"># 创建2x2定值为7的数组</span></span><br><span class="line">print(c)</span><br><span class="line">[[<span class="number">7</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line">d = np.eye(<span class="number">2</span>)        <span class="comment"># 创建2x2的单位矩阵（对角元素为1）</span></span><br><span class="line">print(d)</span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>]]</span><br><span class="line"></span><br><span class="line">d_1 = np.diag([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">50</span>]) <span class="comment">#创建一个对角线为10,20,30,50的对角矩阵</span></span><br><span class="line">print(d_1)</span><br><span class="line">[[<span class="number">10</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span> <span class="number">20</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span> <span class="number">0</span> <span class="number">30</span> <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">50</span>]]</span><br><span class="line"></span><br><span class="line">e = np.arange(<span class="number">15</span>)   <span class="comment">#创建一个一维的0-14的数组</span></span><br><span class="line">print(e)</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span>]</span><br><span class="line"></span><br><span class="line">e_1 = np.arange(<span class="number">4</span>,<span class="number">10</span>)  <span class="comment">#创建一个一维的4-9的数组</span></span><br><span class="line">print(e_1)</span><br><span class="line">[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">e_2 = np.arange(<span class="number">1</span>,<span class="number">14</span>,<span class="number">3</span>)  <span class="comment">#创建一个一维的1-13且以间隔为3的数组</span></span><br><span class="line">print(e_2)</span><br><span class="line">[ <span class="number">1</span> <span class="number">4</span> <span class="number">7</span> <span class="number">10</span> <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">f = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">6</span>)  <span class="comment">#创建一个一维的范围在0-10，长度为6的数组</span></span><br><span class="line">print(f)</span><br><span class="line">[ <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>,  <span class="number">8.</span>, <span class="number">10.</span>]  </span><br><span class="line"><span class="comment">#各个元素的间隔相等，为(10-0)/(6-1) = 2，若不想包含末尾的10，可以添加参数endpoint = False</span></span><br><span class="line"></span><br><span class="line">g = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)  <span class="comment">#把arange创建的一维数组转换为3行4列的二维数组</span></span><br><span class="line">print(g)                        <span class="comment">#同样方法也适用于linspace等</span></span><br><span class="line">[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],              <span class="comment">#注意：使用reshape转换前后的数据量应该相同，12 = 3x4</span></span><br><span class="line"> [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line"> [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]]              </span><br><span class="line"></span><br><span class="line">h = np.random.random((<span class="number">2</span>,<span class="number">2</span>)) <span class="comment"># 2x2的随机数组(矩阵),取值范围在[0.0,1.0)（包含0，不包含1）</span></span><br><span class="line">print(e)</span><br><span class="line">[[ <span class="number">0.72776966</span>  <span class="number">0.94164821</span>]</span><br><span class="line"> [ <span class="number">0.04652655</span>  <span class="number">0.2316599</span> ]]</span><br><span class="line"></span><br><span class="line">i = np.random.randint(<span class="number">4</span>,<span class="number">15</span>,size = (<span class="number">2</span>,<span class="number">2</span>))  <span class="comment">#创建一个取值范围在[4,15)，2行2列的随机整数矩阵</span></span><br><span class="line">print(i)</span><br><span class="line">[[<span class="number">6</span>, <span class="number">5</span>],</span><br><span class="line"> [<span class="number">5</span>, <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">j = np.random.normal(<span class="number">0</span>,<span class="number">0.1</span>,size = (<span class="number">3</span>,<span class="number">3</span>))  </span><br><span class="line"><span class="comment">#创建一个从均值为0，标准差为0.1的正态分布中随机抽样的3x3矩阵</span></span><br><span class="line">print(j)</span><br><span class="line">[[<span class="number">-0.20783767</span>, <span class="number">-0.12406401</span>, <span class="number">-0.11775284</span>],</span><br><span class="line"> [ <span class="number">0.02037018</span>,  <span class="number">0.02898423</span>, <span class="number">-0.02548213</span>],</span><br><span class="line"> [<span class="number">-0.0149878</span> ,  <span class="number">0.05277648</span>,  <span class="number">0.08332239</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="访问、删除、增加ndarray中的元素"><a href="#访问、删除、增加ndarray中的元素" class="headerlink" title="访问、删除、增加ndarray中的元素"></a>访问、删除、增加ndarray中的元素</h3><p>这里主要是提供了一些访问、更改或增加ndarray中某一元素的基础方法。</p>
<ul>
<li>访问&amp;更改</li>
</ul>
<p>类似于访问python list中元素的方式，按照元素的index进行访问或更改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#访问某一元素，这里可以自己多尝试，摸索</span></span><br><span class="line">print(np.arange(<span class="number">6</span>)[<span class="number">3</span>]) <span class="comment">#访问一维数组的某一元素，中括号内填写index</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">print(np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)[<span class="number">1</span>,<span class="number">1</span>]) <span class="comment">#访问二维数组的某一元素，中括号内填写[行,列]</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">print(np.arange(<span class="number">12</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>)[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]) <span class="comment">#访问三位数组中的某一元素，中括号内[组，行，列]</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更改某一元素，用 = 进行赋值和替换即可</span></span><br><span class="line">a = np.arange(<span class="number">6</span>)</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">7</span>      <span class="comment">#先访问，再重新赋值</span></span><br><span class="line">print(a)</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<p>可使用<code>np.delete(ndarray, elements, axis)</code>函数进行删除操作。</p>
<p>这里需要注意的是<code>axis</code>这个参数，课程中只讲到了2维数据中，<code>axis = 0</code>表示选择<code>行</code>，<code>axis = 1</code>表示选择<code>列</code>，但不能机械的认为0就表示行，1就表示列，注意前提<strong>2维数据中</strong>。</p>
<p>在三维数据中，axis = 0表示组，1表示行，2表示列。这是为什么呢？提示一下，三位数组的shape中组、行和列是怎样排序的？</p>
<p>所以，axis的赋值一定要考虑数组的shape。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(np.delete(a,[<span class="number">0</span>],axis = <span class="number">0</span>))  <span class="comment">#思考下，这里删除axis = 0下的第0个，会是什么结果呢？自己试一下</span></span><br></pre></td></tr></table></figure>
<p>再有一点需要注意的是，如果你想让原数据保留删除后的结果，需要重新替换一下才可以。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">np.delete(a,[<span class="number">0</span>],axis = <span class="number">0</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])  <span class="comment">#原数据并未更改</span></span><br><span class="line"></span><br><span class="line">a = np.delete(a,[<span class="number">0</span>],axis = <span class="number">0</span>)  <span class="comment">#重新替换</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">array([[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])   <span class="comment">#原数据已更改</span></span><br></pre></td></tr></table></figure>
<ul>
<li>增加</li>
</ul>
<p>往ndarray中增加元素的办法跟python list也很类似，常用的有两种：</p>
<ul>
<li><p>一种是添加（append），就是将新增的元素添加到ndarray的尾部</p>
<ul>
<li>语法为：<code>np.append(ndarray, elements, axis)</code></li>
<li>参数和delete函数一致，用法也一致，这里不再赘述</li>
</ul>
</li>
<li><p>一种是插入（insert），可以让新增元素插入到指定位置</p>
<ul>
<li>语法为：<code>np.insert(ndarray, index, elements, axis)</code></li>
<li>参数中就多了一个<code>index</code>，指示的是插入新元素的位置。</li>
</ul>
</li>
</ul>
<p>这里值得注意的是，不论是append还是insert，在往多维数组中插入元素时，一定要注意对应axis上的shape要一致。再一个就是，和delete一样，如果你想要更改原数据，需要用<code>a = np.append(a,elements,axis)</code>。</p>
<h3 id="ndarray切片"><a href="#ndarray切片" class="headerlink" title="ndarray切片"></a>ndarray切片</h3><p>前面学了选择ndarray中的某个元素的方法，这里我们学习选择ndarray子集的方法——切片。</p>
<p>对于切片大家并不陌生，在list里面我们也接触过切片，一维的ndarray切片与list无异。需要注意的是，就是理解2维及多维ndarray切片。</p>
<ul>
<li>2维矩阵切片</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(4*4).reshape(4,4)</span><br><span class="line">print(a)</span><br><span class="line">out:</span><br><span class="line">array([[ 0,  1,  2,  3],</span><br><span class="line">       [ 4,  5,  6,  7],</span><br><span class="line">       [ 8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15]])</span><br><span class="line">a[:,:-1]</span><br><span class="line">out:</span><br><span class="line">array([[ 0,  1,  2],</span><br><span class="line">       [ 4,  5,  6],</span><br><span class="line">       [ 8,  9, 10],</span><br><span class="line">       [12, 13, 14]])</span><br></pre></td></tr></table></figure>
<p>这里可以看出，我们筛选了a矩阵中前三列的所有行，这是如何实现的呢？</p>
<p>切片的第一个元素<code>:</code>表示的是选择所有行，第二个元素<code>:-1</code>表示的是从第0列至最后一列（不包含），所以结果如上所示。</p>
<p>再看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[1:3,:]</span><br><span class="line">out:</span><br><span class="line">array([[ 4,  5,  6,  7],</span><br><span class="line">       [ 8,  9, 10, 11]])</span><br></pre></td></tr></table></figure>
<p>筛选的是第2-3行的所有列。</p>
<ul>
<li>一个常用的切片</li>
</ul>
<p>以列的形式获取最后一列数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a[:,3:]</span><br><span class="line">out:</span><br><span class="line">array([[ 3],</span><br><span class="line">       [ 7],</span><br><span class="line">       [11],</span><br><span class="line">       [15]])</span><br></pre></td></tr></table></figure>
<p>以一维数组的形式获取最后一列数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[:,-1]</span><br><span class="line">out:</span><br><span class="line">array([ 3,  7, 11, 15])</span><br></pre></td></tr></table></figure>
<p>上面两种方法经常会用到，前者的shape为(4,1)，后者为(4,)。</p>
<h3 id="ndarray筛选"><a href="#ndarray筛选" class="headerlink" title="ndarray筛选"></a>ndarray筛选</h3><ul>
<li>选择ndarray的对角线</li>
</ul>
<p>所用函数为<code>np.diag(ndarray, k=N)</code>，其中参数k的取值决定了按照哪一条对角线选择数据。</p>
<p>默认k = 0，取主对角线；</p>
<p>k = 1时，取主对角线上面1行的元素；</p>
<p>k = -1时，取主对角线下面1行的元素。</p>
<p><strong>思考</strong>：这个函数只能选择主对角线上的元素，那如果想要获取副对角线上的元素呢？</p>
<p>尝试自己搜索一下关键词<code>numpy opposite diagonal</code>寻找答案。</p>
<p>不建议你直接点<a href="https://stackoverflow.com/questions/16114333/getting-the-opposite-diagonal-of-a-numpy-array" target="_blank" rel="noopener">getting the opposite diagonal of a numpy array</a>。</p>
<ul>
<li>提取ndarray中的唯一值</li>
</ul>
<p>所用函数为<code>np.unique(ndarray)</code>，注意unique也可以添加参数axis来控制评判唯一值的轴方向，不好理解可以看示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">     [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">     [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">print(np.unique(a))    <span class="comment">#查看二维数组a中的唯一值</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">print(np.unique(a,axis = <span class="number">0</span>))  <span class="comment">#查看a中的唯一行（也就是没有重复的行）</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line">print(np.unique(a,axis = <span class="number">1</span>))  <span class="comment">#查看a中的唯一列</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line">print(np.unique(a[<span class="number">0</span>]))  <span class="comment">#查看a中第一行的唯一值</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>通过布尔运算筛选</li>
</ul>
<p>这里在中括号中添加筛选条件，当该条件的结果为True时（即满足条件时），返回该值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X[X &gt; <span class="number">10</span>] <span class="comment">#筛选数组X中大于10的数据</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，当输入多个筛选条件时，<code>&amp;</code>表示与，<code>|</code>表示或，<code>~</code>表示非。</p>
<h3 id="ndarray运算"><a href="#ndarray运算" class="headerlink" title="ndarray运算"></a>ndarray运算</h3><ul>
<li>集合运算</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.intersect1d(x,y) <span class="comment">#取x与y的交集</span></span><br><span class="line">np.setdiff1d(x,y)   <span class="comment">#取x与y的差集，返回的是在x中且没在y中的元素</span></span><br><span class="line">np.union1d(x,y)     <span class="comment">#取x与y的并集</span></span><br></pre></td></tr></table></figure>
<ul>
<li>算术运算</li>
</ul>
<p>我们可以通过<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>或<code>np.add</code>、<code>np.substract</code>、<code>np.multiply</code> 、<code>np.divide</code>来对两个矩阵进行元素级的加减乘除运算，因为是元素级的运算，所以两个矩阵的shape必须要严格一致。</p>
<blockquote>
<p>上面涉及到的乘法是元素对应相乘，也就是点乘，那矩阵的叉乘呢？可以了解下<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.matmul.html#numpy.matmul" target="_blank" rel="noopener">numpy.matmul</a>函数。</p>
</blockquote>
<p>这里需要注意的是，课程中讲的“可广播”，其实指的就是A和B两个矩阵shape可能不一致，但是A可以拆分为整数个与B具有相同shape的矩阵，这样在进行元素级别的运算时，就会先将A进行拆分，然后与B进行运算，结果再组合一起就可以。这里的A就是“可广播”矩阵。</p>
<h3 id="ndarray排序"><a href="#ndarray排序" class="headerlink" title="ndarray排序"></a>ndarray排序</h3><p>我们使用<code>np.sort()</code>和<code>ndarray.sort()</code>来对ndarray进行排序。</p>
<p>相同的是：</p>
<p>二者都可以使用参数<code>axis</code>来决定依照哪个轴进行排序，axis = 0时按照列排序，axis = 1时按照行排序；</p>
<p>不同的是：</p>
<p><code>np.sort()</code>不会更改原数组；<code>ndarray.sort()</code>会更改原数组。</p>
<h3 id="numpy迷你项目"><a href="#numpy迷你项目" class="headerlink" title="numpy迷你项目"></a>numpy迷你项目</h3><p>这里涉及到一个概念，叫做<strong>数据标准化</strong>。</p>
<p>数据的标准化(normalization)是将数据按比例缩放，使之落入一个小的特定区间。在某些比较和评价的指标处理中经常会用到，去除数据的单位限制，将其转化为无量纲的纯数值，便于不同单位或量级的指标能够进行比较和加权。</p>
<p>有很多种对数据进行标准化处理的方法，我们课程中选择的是利用数据均值和标准差进行标准化：</p>
<p><img src="https://s1.ax1x.com/2018/12/11/FJWC3F.png" alt="FJWC3F.png"></p>
<p>对某一列中某一值进行标准化就是将该值减去该列的平均值，然后除以该列的标准差。标准化后的序列，均值为0，标准差为1，且无量纲。</p>
<p>标准化后的数据，没有量纲，方便计算和比较，在机器学习中的很多算法都需要将数据进行标准化。</p>
<blockquote>
<p>但是基于本章的要求，我们主要是学习numpy的基本操作即可，具体的数据标准化还有算法可以之后在机器学习课程中学习。</p>
</blockquote>
<p>这里需要注意的是：</p>
<ul>
<li><code>np.random.permutation()</code> </li>
</ul>
<p><code>np.random.permutation(N)</code> 函数会创建一个从 0 到 <code>N - 1</code>的随机排列的整数集。这个整数集也是ndarray类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.random.permutation(<span class="number">5</span>)</span><br><span class="line">array([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>将数据集切分为训练集、测试集和交叉集。</li>
</ul>
<p>这里的切分有两点隐形要求：</p>
<p>1.随机性，三个数据集中的数据必须是随机分配的；</p>
<p>2.三个数据集的合集必须为数据集。</p>
<pre><code>考虑到上面学到的`np.random.permutation()` 函数，所以我们的思路可以是这样的：

1. 使用`permutation()`函数，将数据集的行数当作N，这样就可以得到一个随机排列的行索引序列；
2. 使用切片，将刚才的随机行索引序列，按照训练集、测试集和交叉集的比例`6:2:2`进行切分；
3. 使用索引访问，获取切分后的数据，即`ndarray[index]`的方式。
</code></pre><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><h3 id="Pandas简介"><a href="#Pandas简介" class="headerlink" title="Pandas简介"></a>Pandas简介</h3><p><strong>Pandas</strong> 是 Python 中的数据操纵和分析软件包，它是基于Numpy去开发的，所以Pandas的数据处理速度也很快，而且Numpy中的有些函数在Pandas中也能使用，方法也类似。</p>
<p>Pandas 为 Python 带来了两个新的数据结构，即 <strong>Pandas Series</strong>(可类比于表格中的某一列)和 <strong>Pandas DataFrame</strong>(可类比于表格)。借助这两个数据结构，我们能够轻松直观地处理<em>带标签</em>数据和<em>关系</em>数据。</p>
<blockquote>
<p>Series中各个元素的数据类型可以不一致，DataFrame也是如此，这与numpy的ndarray不同。</p>
</blockquote>
<h3 id="创建Pandas-Series"><a href="#创建Pandas-Series" class="headerlink" title="创建Pandas Series"></a>创建Pandas Series</h3><p>可以使用 <code>pd.Series(data, index)</code> 命令创建 Pandas Series，其中<code>data</code>表示输入数据， <code>index</code> 为对应数据的索引，除此之外，我们还可以添加参数<code>dtype</code>来设置该列的数据类型。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.Series(data = [<span class="number">30</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>], index = [<span class="string">'eggs'</span>, <span class="string">'apples'</span>, <span class="string">'milk'</span>, <span class="string">'bread'</span>],dtype=float)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">eggs      <span class="number">30.0</span></span><br><span class="line">apples     <span class="number">6.0</span></span><br><span class="line">milk       <span class="number">7.0</span></span><br><span class="line">bread      <span class="number">5.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p><code>data</code>除了可以输入列表之外，还可以输入字典，或者是直接一个标量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#data输入字典</span></span><br><span class="line">pd.Series(data = &#123;<span class="string">'eggs'</span>:<span class="number">30</span>,<span class="string">'apples'</span>: <span class="number">6</span>,  <span class="string">'milk'</span>:<span class="number">7</span>, <span class="string">'bread'</span>:<span class="number">5</span>&#125;,dtype=float)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">apples     <span class="number">6.0</span></span><br><span class="line">bread      <span class="number">5.0</span></span><br><span class="line">eggs      <span class="number">30.0</span></span><br><span class="line">milk       <span class="number">7.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="comment">#data输入某一标量</span></span><br><span class="line">pd.Series(data = <span class="number">7</span>, index = [<span class="string">'eggs'</span>, <span class="string">'apples'</span>, <span class="string">'milk'</span>, <span class="string">'bread'</span>])</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">eggs      <span class="number">7</span></span><br><span class="line">apples    <span class="number">7</span></span><br><span class="line">milk      <span class="number">7</span></span><br><span class="line">bread     <span class="number">7</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="访问和删除Series中的元素"><a href="#访问和删除Series中的元素" class="headerlink" title="访问和删除Series中的元素"></a>访问和删除Series中的元素</h3><ul>
<li><strong>访问</strong></li>
</ul>
<p>访问Series中的元素有两种方法：</p>
<p>一种类似于从列表中按照索引访问数据，一种类似于从字典中按照<strong>key</strong>来访问<strong>value</strong>。</p>
<p>下面看示例：</p>
<p><img src="https://s1.ax1x.com/2018/12/11/FY9vQg.png" alt="    FY9vQg.png"></p>
<p>从上面代码里也能发现，Pandas提供的<code>iloc</code>与<code>loc</code>分别对应着按索引访问和按key访问。</p>
<ul>
<li><strong>修改</strong></li>
</ul>
<p>因为Series是可更改类型，若想更改其中某一项，只需访问它然后重新赋值即可。</p>
<ul>
<li><strong>删除</strong></li>
</ul>
<p>可以使用 <code>.drop()</code> 方法删除 Pandas Series 中的条目。<code>Series.drop(label)</code> 方法会从给定 <code>Series</code> 中删除给定的 <code>label</code>。这个<code>label</code>可以是单个label或这是label组成的list。</p>
<p><img src="https://s1.ax1x.com/2018/12/11/FYPWKe.png" alt="FYPWKe.png"></p>
<p>但需要注意的是，<code>.drop()</code>函数并不会修改原来的数据，如果你想要修改原数据的话，可以选择添加参数<code>inplace = True</code>或者是用原数据替换<code>s = s.drop(label)</code></p>
<h3 id="Series运算"><a href="#Series运算" class="headerlink" title="Series运算"></a>Series运算</h3><p>和ndarray一样，Series也可以进行元素级的算术运算，也可以使用np中提供的各种运算函数，如<code>sqrt()</code>等等。</p>
<p>这里可以想一下，如果Series中包含字符串，然后再进行乘法会是什么结果？</p>
<p>可以回想下字符串的知识<code>&#39;*&#39;*10</code>的结果是什么？</p>
<h3 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h3><p>我们使用<code>pd.DataFrame(data, index, columns)</code>来创建一个DataFrame。</p>
<p>其中：</p>
<p><code>data</code>是数据，可以输入ndarray，或者是字典（字典中可以包含Series或arrays或），或者是DataFrame；</p>
<p><code>index</code>是索引，输入列表，如果没有设置该参数，会默认以0开始往下计数；</p>
<p><code>columns</code>是列名，输入列表，如果没有设置该参数，会默认以0开始往右计数；</p>
<p>示例：</p>
<p><img src="https://s1.ax1x.com/2018/12/11/FYkQDe.png" alt="FYkQDe.png"></p>
<p>从上述代码中可以看出，字典<code>d</code>中的<code>key</code>被当作列名，<code>value</code>被当作dataframe中的数据。</p>
<p><strong>思考</strong>：如果在上述代码中添加一个columns列，如<code>df = pd.DataFrame(data=d,index = [&#39;a&#39;,&#39;b&#39;],columns = [&#39;col_1&#39;,&#39;col_2&#39;])</code>，会返回什么结果呢？</p>
<h3 id="访问DataFrame中的元素"><a href="#访问DataFrame中的元素" class="headerlink" title="访问DataFrame中的元素"></a>访问DataFrame中的元素</h3><p>与访问Series中的元素类似，我们可以通过列表式索引访问，也可以通过字典式Key值访问。</p>
<ul>
<li>创建一个DataFrame</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/12/12/FYfMh6.png" alt="FYfMh6.png"></p>
<ul>
<li>访问某一行</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/12/12/FYh15q.png" alt="FYh15q.png"></p>
<ul>
<li>访问多行</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/12/12/FY4lOe.png" alt="FY4lOe.png"></p>
<ul>
<li>访问某一列</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/12/12/FY4nW6.png" alt="FY4nW6.png"></p>
<ul>
<li>访问多列</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/12/12/FY4tYt.png" alt="FY4tYt.png"></p>
<blockquote>
<p>使用df.iloc[:,0:2]这种方法只能筛选出连续的列，那如果想要筛选的列分别在1,3,5,10:17怎么办呢？可以搜一下<code>np.r_</code>的用法。</p>
</blockquote>
<ul>
<li>访问某一行列的元素</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/12/12/FY4aSf.png" alt="FY4aSf.png"></p>
<h3 id="删除、增加元素"><a href="#删除、增加元素" class="headerlink" title="删除、增加元素"></a>删除、增加元素</h3><ul>
<li>删除元素</li>
</ul>
<p>我们使用<code>.drop</code>函数删除元素，默认为删除行，添加参数<code>axis = 1</code>来删除列。</p>
<p><img src="https://s1.ax1x.com/2018/12/12/FY5x2V.png" alt="FY5x2V.png"></p>
<p>值得注意的是，<code>drop</code>函数不会修改原数据，如果想直接对原数据进行修改的话，可以选择添加参数<code>inplace = True</code>或用原变量名重新赋值替换。</p>
<ul>
<li>增加元素</li>
</ul>
<p>这里介绍了两种方法，一种是<code>append()</code>，另外一种是<code>insert()</code>，这两种方法都比较简单，可类比于python list中的两种方法进行学习。</p>
<p>此外，Pandas还提供了其他更为复杂的做DataFrame融合的函数，比如说<code>concat()</code>、<code>merge()</code>、<code>join()</code>等等，相对难理解一些，我会单独出一份导学详细介绍这几个数据融合函数。</p>
<h3 id="更改行列标签"><a href="#更改行列标签" class="headerlink" title="更改行列标签"></a>更改行列标签</h3><p>使用函数<code>rename()</code>即可。具体用法如下：</p>
<p><img src="https://s1.ax1x.com/2018/12/12/FYIIiR.png" alt="FYIIiR.png"></p>
<p>除此之外，还可以使用隐匿函数lambda来对行列标签进行统一处理，比如：</p>
<p><img src="https://s1.ax1x.com/2018/12/12/FYIoJ1.png" alt="FYIoJ1.png"></p>
<p>需要注意的是，<code>rename()</code>函数同样不会更改原数据，如果想直接对原数据进行修改的话，可以选择添加参数<code>inplace = True</code>或用原变量名重新赋值替换。</p>
<h3 id="更改索引"><a href="#更改索引" class="headerlink" title="更改索引"></a>更改索引</h3><p>可以使用函数<code>set_index(index_label)</code>，将数据集的index设置为<code>index_label</code>。</p>
<p>除此之外，还可以使用函数<code>reset_index()</code>重置数据集的index为0开始计数的数列。</p>
<h3 id="缺失值-NaN-处理"><a href="#缺失值-NaN-处理" class="headerlink" title="缺失值(NaN)处理"></a>缺失值(NaN)处理</h3><p><code>NaN</code>就是<strong>Not a Number</strong>的缩写，表示这里有数据缺失。</p>
<ul>
<li>查找NaN</li>
</ul>
<p>我们可以使用<code>isnull()</code>和<code>notnull()</code>函数来查看数据集中是否存在缺失数据，在该函数后面添加<code>sum()</code>函数来对缺失数量进行统计。除此之外，还可以使用<code>count()</code>函数对非NaN数据进行统计计数。</p>
<p><img src="https://s1.ax1x.com/2018/12/12/FYIzFA.png" alt="FYIzFA.png"></p>
<ul>
<li>删除NaN</li>
</ul>
<p>使用<code>dropna(axis)</code>函数可以删除包含NaN的行或列。</p>
<blockquote>
<p> <code>dropna()</code>函数还有一个参数是<code>how</code>，当<code>how = all</code>时，只会删除全部数据都为NaN的列或行。</p>
</blockquote>
<p>同样，该函数也不会修改原数据集。</p>
<ul>
<li>替换NaN</li>
</ul>
<p>使用<code>fillna()</code>函数可以替换NaN为某一值。其参数如下：</p>
<ol>
<li><strong>value</strong>：用来替换NaN的值</li>
<li><strong>method</strong>：常用有两种，一种是<code>ffill</code>前向填充，一种是<code>backfill</code>后向填充</li>
<li><strong>axis</strong>：0为行，1为列</li>
<li><strong>inplace</strong>：是否替换原数据，默认为False</li>
<li><strong>limit</strong>：接受int类型的输入，可以限定替换前多少个NaN</li>
</ol>
<blockquote>
<p> 一般来说，我们常用均值去替换NaN。</p>
</blockquote>
<p>还可以使用<code>interpolate()</code>函数按照某一方法来替换NaN，课程中介绍了method为<code>linear</code>时的用法，即忽略索引并将值视为相等间距，这是该函数的默认方法。更多method及解读请戳<a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.interpolate.html" target="_blank" rel="noopener">pandas.DataFrame.interpolate</a></p>
<h3 id="在Pandas中处理数据"><a href="#在Pandas中处理数据" class="headerlink" title="在Pandas中处理数据"></a>在Pandas中处理数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(filename) <span class="comment">#读取csv文件</span></span><br><span class="line">df.info()  <span class="comment">#查看数据集信息</span></span><br><span class="line">df.head()  <span class="comment">#查看前五行</span></span><br><span class="line">df.tail()  <span class="comment">#查看后五行</span></span><br><span class="line">df.sample()  <span class="comment">#查看随机一行</span></span><br><span class="line">df.describe() <span class="comment">#查看数据类型的基本统计信息</span></span><br><span class="line">df.corr() <span class="comment">#查看各列之间的相关系数</span></span><br><span class="line"></span><br><span class="line">df.groupby() <span class="comment">#将数据按照某一列进行聚类，后续接数据统计函数，如mean()，sum()等</span></span><br></pre></td></tr></table></figure>
<h1 id="项目内容"><a href="#项目内容" class="headerlink" title="项目内容"></a>项目内容</h1><p>本首是Python项目的第2周，主要还是理解项目和准备项目文件，请大家做到以下几点：</p>
<p><strong>Project2/week1的项目要求：</strong>（应该已经做完）</p>
<ul>
<li>完成/项目：探索美国共享单车数据/的1-3节内容</li>
<li>搭建本地anaconda环境（Python3版本）确保Spyder可以使用</li>
<li>下载bikeshare-new-2.zip项目文件。如果教室里面不能下载，请尝试下载下面的链接：<a href="https://github.com/mengfanchun2017/DAND-Basic/blob/master/Project1/Project1Files/bikeshare-new-2.zip" target="_blank" rel="noopener">https://github.com/mengfanchun2017/DAND-Basic/blob/master/Project1/Project1Files/bikeshare-new-2.zip</a></li>
</ul>
<p><strong>Project2/week2的项目要求</strong> （本周要求和，做完了画第二个勾勾）</p>
<ul>
<li>用spyder打开项目文件浏览</li>
<li>了解项目文件中有几个函数，函数名和输入是什么（不用看明白和尝试做）</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/02/2018-12-5-mini-batch-gradient-descent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/02/2018-12-5-mini-batch-gradient-descent/" class="post-title-link" itemprop="url">Python Code of Mini-Batch Gradient Descent</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-02 07:30:09" itemprop="dateCreated datePublished" datetime="2018-12-02T07:30:09+08:00">2018-12-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 12:51:55" itemprop="dateModified" datetime="2019-04-03T12:51:55+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DSND/" itemprop="url" rel="index"><span itemprop="name">DSND</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/12/02/2018-12-5-mini-batch-gradient-descent/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/12/02/2018-12-5-mini-batch-gradient-descent/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Mini-Batch Gradient Descent是介于<em>batch gradient descent</em>（BGD）和<em>stochastic gradient descent</em>（SGD）之间的一种线性回归优化算法，它是将数据分为多个小的数据集（batches），每个数据集具有大致相同的点数，然后在每个数据集中应用Absolute Trick或者是Square Trick算法，来更新回归系数。</p>
<p>它的运算速度比BSD快，比SGD慢；精度比BSD低，比SGD高。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MSEStep</span><span class="params">(X, y, W, b, learn_rate = <span class="number">0.001</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This function implements the gradient descent step for squared error as a</span></span><br><span class="line"><span class="string">    performance metric.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    X : array of predictor features</span></span><br><span class="line"><span class="string">    y : array of outcome values</span></span><br><span class="line"><span class="string">    W : predictor feature coefficients</span></span><br><span class="line"><span class="string">    b : regression function intercept</span></span><br><span class="line"><span class="string">    learn_rate : learning rate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    W_new : predictor feature coefficients following gradient descent step</span></span><br><span class="line"><span class="string">    b_new : intercept following gradient descent step</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># compute errors</span></span><br><span class="line">    <span class="comment"># the squared trick formula </span></span><br><span class="line">    y_pred = np.matmul(X, W) + b <span class="comment">#Attention:the order of X and W</span></span><br><span class="line">    error = y - y_pred</span><br><span class="line">    <span class="comment">#y_pred is a 1-D array,so is the error</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># compute steps</span></span><br><span class="line">    W_new = W + learn_rate * np.matmul(error, X) <span class="comment">#Attention:the order of X and error</span></span><br><span class="line">    b_new = b + learn_rate * error.sum() </span><br><span class="line">    <span class="keyword">return</span> (W_new, b_new)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">miniBatchGD</span><span class="params">(X, y, batch_size = <span class="number">20</span>, learn_rate = <span class="number">0.005</span>, num_iter = <span class="number">25</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This function performs mini-batch gradient descent on a given dataset.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    X : array of predictor features</span></span><br><span class="line"><span class="string">    y : array of outcome values</span></span><br><span class="line"><span class="string">    batch_size : how many data points will be sampled for each iteration</span></span><br><span class="line"><span class="string">    learn_rate : learning rate</span></span><br><span class="line"><span class="string">    num_iter : number of batches used</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    regression_coef : array of slopes and intercepts generated by gradient</span></span><br><span class="line"><span class="string">      descent procedure</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n_points = X.shape[<span class="number">0</span>]</span><br><span class="line">    W = np.zeros(X.shape[<span class="number">1</span>]) <span class="comment"># coefficients</span></span><br><span class="line">    b = <span class="number">0</span> <span class="comment"># intercept</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># run iterations</span></span><br><span class="line">    <span class="comment">#hstack为水平堆叠函数 为什么要堆叠呢？</span></span><br><span class="line">    <span class="comment">#类似zip，可以实现for W,b in regression_coef:print W,b来提取W和b</span></span><br><span class="line">    regression_coef = [np.hstack((W,b))]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_iter):</span><br><span class="line">        <span class="comment">#从0-100中随机选择batch_size个数，作为batch</span></span><br><span class="line">        batch = np.random.choice(range(n_points), batch_size)</span><br><span class="line">        <span class="comment">#按照batch从X中选出数据</span></span><br><span class="line">        X_batch = X[batch,:]<span class="comment">#为2-D矩阵</span></span><br><span class="line">        y_batch = y[batch]<span class="comment">#为1-D数组</span></span><br><span class="line">        W, b = MSEStep(X_batch, y_batch, W, b, learn_rate)</span><br><span class="line">        regression_coef.append(np.hstack((W,b)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (regression_coef)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># perform gradient descent</span></span><br><span class="line">    data = np.loadtxt(<span class="string">'data.csv'</span>, delimiter = <span class="string">','</span>)</span><br><span class="line">    X = data[:,:<span class="number">-1</span>]<span class="comment">#提取第一列，为2-D矩阵</span></span><br><span class="line">    y = data[:,<span class="number">-1</span>]<span class="comment">#提取第二列，为1-D数组</span></span><br><span class="line">    regression_coef = miniBatchGD(X, y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plot the results  </span></span><br><span class="line">    plt.figure()</span><br><span class="line">    X_min = X.min()</span><br><span class="line">    X_max = X.max()</span><br><span class="line">    counter = len(regression_coef)</span><br><span class="line">    <span class="keyword">for</span> W, b <span class="keyword">in</span> regression_coef:</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line">         <span class="comment">#color为[R,G,B]的列表，范围都在0-1之间，[0,0,0]为黑色，[1,1,1]为白色</span></span><br><span class="line">        color = [<span class="number">1</span> - <span class="number">0.92</span> ** counter <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">        <span class="comment">#绘制一条点(X_min,X_min * W + b)与点(X_max, X_max * W + b)之间的一条直线</span></span><br><span class="line">        plt.plot([X_min, X_max],[X_min * W + b, X_max * W + b], color = color)</span><br><span class="line">    plt.scatter(X, y, zorder = <span class="number">3</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="https://s1.ax1x.com/2018/12/05/FldOgg.png" alt="FldOgg.png"></p>
<p>在结果中，颜色最浅的是最开始的回归线，最深的则为最终的回归线。</p>
<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>理论知识参见<a href>Linear Regression 总结</a>，这里只对代码中出现的新函数或新用法进行讲解。</p>
<h2 id="numpy-matmul-a-b"><a href="#numpy-matmul-a-b" class="headerlink" title="numpy.matmul(a,b)"></a>numpy.matmul(a,b)</h2><p>该函数用来计算两个arrays的乘积。</p>
<p>需要注意的是，由于a和b维度的不同，会使得函数的结果计算方式不同，一共三种：</p>
<ul>
<li><p>如果a和b都是2维的，则做普通矩阵乘法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">b = [[<span class="number">4</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">np.matmul(a, b)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果a和b中有一个是大于2维的，则会将其理解为多个矩阵stack后的结果，进行计算时也会进行相应的拆分运算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">2</span>*<span class="number">2</span>*<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">b = np.arange(<span class="number">2</span>*<span class="number">2</span>*<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>))</span><br><span class="line">np.matmul(a,b).shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>a被理解为2个2x4矩阵的stack</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure>
<p>b被理解为2个4x2矩阵的stack</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">14</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure>
<p><code>np.matmul(a,b)</code>会将a中的两个矩阵与b中的两个矩阵对应相乘，每对相乘的结果都是一个2x2的矩阵，所以结果就是一个2x2x2的矩阵。</p>
</li>
<li><p>如果a或b有一个是一维的，那么就会为该一维数组补充1列或1行，进而提升为二维矩阵，然后用非补充行或列去和另外一个二维矩阵进行运算，得到的结果再将补充的1去掉。（<strong>这个是最难理解的，可以多测试下，用代码结果理解</strong>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">np.matmul(a, b)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>a是一个2x2的矩阵，b是一个shape为(2,)的一维数组，那么matmul的计算步骤如下：</p>
<ul>
<li>计算中，矩阵a在前，数组b在后，所以需要让a的列数与升维之后b矩阵的行数相等</li>
<li>所以，升维后b矩阵的shape应为(2,1)，这个1添加到了列上</li>
<li>进行矩阵乘法计算，得到shape为(2,1)，这时候再将这个1去掉</li>
<li>最终结果的shape为(2,)，变为一维数组</li>
</ul>
<p>我们试着将a与b的顺序对调，看一下matmul是怎么计算的：</p>
<ul>
<li>对调后，数组b在前，矩阵a在后，需要将升维后b矩阵的列数与矩阵a的行数相等</li>
<li>所以，升维后b矩阵的shape应该为(1,2)，这个1添加到了行上</li>
<li>进行矩阵乘法，得到的shape为(1,2)，将这个1去掉</li>
<li>最终结果的shape为(2,)，变为一维数组</li>
</ul>
</li>
</ul>
<h2 id="numpy-hstack"><a href="#numpy-hstack" class="headerlink" title="numpy.hstack()"></a>numpy.hstack()</h2><p>我们先来看看<code>numpy.stack()</code>函数。</p>
<ul>
<li>函数用法为：numpy.stack(arrays,axis = 0)</li>
<li>第一个参数为arrays，可以输入多维数组或者列表，也可以输入由多个一维数组或列表组成的元组</li>
<li>第二个参数为axis，输入数字，决定了按照arrays的哪个维度进行stack。比如说，输入的arrays的shape为(3,4,3)，那么axis = 0/1/2就分别对应arrays的组/行/列。</li>
</ul>
<p>这个函数中的axis有些抽象，我们看具体示例：</p>
<ul>
<li>定义了一个列表</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/12/06/F1PSIS.png" alt="F1PSIS.png"></p>
<p>结果的排版有点问题，为了方便后面对照，把结果对齐如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]]),</span><br><span class="line">    array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]]),</span><br><span class="line">    array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>axis = 0，则按照第0个维度<code>组</code>进行堆叠，即：</p>
<p><img src="https://s1.ax1x.com/2018/12/06/F1PqFU.png" alt="F1PqFU.png"></p>
<p>结果为：</p>
<p><img src="https://s1.ax1x.com/2018/12/06/F1PLYF.png" alt="F1PLYF.png"></p>
</li>
<li><p>axis = 1，则按照第1个维度<code>行</code>进行堆叠，即：</p>
<p><img src="https://s1.ax1x.com/2018/12/06/F1Pvl9.png" alt="F1Pvl9.png"></p>
<p>结果为：</p>
<p><img src="https://s1.ax1x.com/2018/12/06/F1PzO1.png" alt="F1PzO1.png"></p>
</li>
<li><p>axis = 2，则按照第二个维度<code>列</code>进行堆叠，即：</p>
<p><img src="https://s1.ax1x.com/2018/12/06/F13zdO.png" alt="F13zdO.png"></p>
<p>结果为：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1544074512445.png" alt="1544074512445"></p>
<p>这个基本很少用到。</p>
</li>
</ul>
<p><strong>numpy.hstack()</strong>函数就是horizontal（水平）方向的堆叠，示例：</p>
<p><img src="https://s1.ax1x.com/2018/12/06/F18qAS.png" alt="F18qAS.png"></p>
<p><strong>numpy.vstack()</strong>函数就是在垂直方向堆叠。</p>
<h2 id="ndarray的切片"><a href="#ndarray的切片" class="headerlink" title="ndarray的切片"></a>ndarray的切片</h2><p>一维ndarray的切片方式和list无异，这里主要讲一下二维矩阵的切片方法。</p>
<ul>
<li>矩阵切片</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">4</span>*<span class="number">4</span>).reshape(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[:,:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure>
<p>这里可以看出，我们筛选了a矩阵中前三列的所有行，这是如何实现的呢？</p>
<p>切片的第一个元素<code>:</code>表示的是选择所有行，第二个元素<code>:-1</code>表示的是从第0列至最后一列（不包含），所以结果如上所示。</p>
<p>再看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>:<span class="number">3</span>,:]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>
<p>筛选的是第2-3行的所有列。</p>
<ul>
<li>一个常用的切片</li>
</ul>
<p>以列的形式获取最后一列数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[:,<span class="number">3</span>:]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">array([[ <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">7</span>],</span><br><span class="line">       [<span class="number">11</span>],</span><br><span class="line">       [<span class="number">15</span>]])</span><br></pre></td></tr></table></figure>
<p>以一维数组的形式获取最后一列数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[:,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">array([ <span class="number">3</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>])</span><br></pre></td></tr></table></figure>
<p>上面两种方法经常会用到，前者的shape为(4,1)，后者为(4,)。</p>
<h2 id="matplotlib相关"><a href="#matplotlib相关" class="headerlink" title="matplotlib相关"></a>matplotlib相关</h2><ul>
<li><p>color</p>
<p>代码中涉及到的语句为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color = [<span class="number">1</span> - <span class="number">0.92</span> ** counter <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<p>matplotlib中的color可以输入RGB格式，即[R,G,B]，这里值得注意的是它们的取值范围都在0到1之间，其中[0,0,0]为黑色，[1,1,1]为白色。</p>
<p>在如上语句中，列表由三个相等的数值元素组成，保证了颜色为白-灰-黑，数值随着counter的减小，由1趋近于0，反映在可视化上就是颜色由白逐渐变黑。</p>
<p>这真是一个画渐变过程的好方法呀！！！</p>
</li>
<li><p>plot([x_1,x_2],[y_1,y_2])</p>
<p>这里就是两点式绘图，根据点(x_1,y_1)和点(x_2,y_2)画一条直线。</p>
</li>
<li><p>zorder</p>
<p>也就是z-order，类似于PS里面的图层顺序，下面的图层会被上面的图层遮挡。</p>
<p>参考<a href="https://matplotlib.org/gallery/misc/zorder_demo.html#sphx-glr-gallery-misc-zorder-demo-py" target="_blank" rel="noopener">Zorder Demo</a>中队zorder的介绍，可以知道，zorder越大，图层越靠上，所以在上面的代码中，我们在scatter中设定zorder为3，也就是最上层，这样就可以保证渐变的回归线不会压在散点图上面了。</p>
<p><img src="https://s1.ax1x.com/2018/12/06/F1JYiF.png" alt="F1JYiF.png"></p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/02/2018-12-2-Anaconda配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/02/2018-12-2-Anaconda配置/" class="post-title-link" itemprop="url">Anaconda&Jupyter Notebook配置</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-02 07:30:09" itemprop="dateCreated datePublished" datetime="2018-12-02T07:30:09+08:00">2018-12-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 12:51:55" itemprop="dateModified" datetime="2019-04-03T12:51:55+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DAND/" itemprop="url" rel="index"><span itemprop="name">DAND</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/12/02/2018-12-2-Anaconda配置/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/12/02/2018-12-2-Anaconda配置/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很多同学对Anaconda和Jupyter Notebook的安装与配置有疑惑，这里对课程中的<a href="https://classroom.udacity.com/nanodegrees/nd002-cn-basic-vip/parts/e566ad37-6119-4448-a6bc-7ade73ef3992" target="_blank" rel="noopener">选修：配置Anaconda和Jupyter Notebook</a>作为一个补充。</p>
<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>点击<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">下载链接</a>，先选择你的操作系统，然后选择<code>Python 3.7 version</code>版本下载。</p>
<p><img src="https://s1.ax1x.com/2018/12/02/Fu1fsg.png" alt="Fu1fsg.png"></p>
<p>安装过程中，记得这里的两个框，都勾选上。</p>
<p><img src="https://s1.ax1x.com/2018/12/02/Fu1Ids.png" alt="Fu1Ids.png"></p>
<hr>
<h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><p>安装完Anaconda之后，Windows用户可以通过<code>开始</code>-<code>所有程序</code>找到<code>Anaconda</code>的文件夹，在文件夹下有三个程序是你经常会用到的，分别是：</p>
<p><strong>Anaconda Prompt</strong>：这里就是Anaconda的控制台，你进行<a href="https://classroom.udacity.com/nanodegrees/nd002-cn-basic-vip/parts/e566ad37-6119-4448-a6bc-7ade73ef3992/modules/2424424b-f71a-4c80-a34c-9a1f47e35cd5/lessons/c6a12f2e-63f2-4007-a2c3-dd3e5f06f3cb/concepts/9310a67f-9b23-449e-8949-4312dc718ef9" target="_blank" rel="noopener">第三方包的管理</a>和<a href="https://classroom.udacity.com/nanodegrees/nd002-cn-basic-vip/parts/e566ad37-6119-4448-a6bc-7ade73ef3992/modules/2424424b-f71a-4c80-a34c-9a1f47e35cd5/lessons/c6a12f2e-63f2-4007-a2c3-dd3e5f06f3cb/concepts/14783a82-d656-436b-bc3f-12f7abe03529" target="_blank" rel="noopener">编程环境的管理</a>都是在这里进行。但是现阶段用不到。</p>
<p><strong>Jupyter Notebook</strong>：使用非常非常频繁的web文档，在项目三和项目四中都会用到。</p>
<p><strong>Spyder</strong>：python的IDE(集成开发环境)，在项目二中会用到。</p>
<p><img src="https://s1.ax1x.com/2018/12/02/Fu3BlT.png" alt="Fu3BlT.png"></p>
<h1 id="Jupter-Notebook"><a href="#Jupter-Notebook" class="headerlink" title="Jupter Notebook"></a>Jupter Notebook</h1><p>notebook的使用技巧在教室内说得很详细了，这里只补充一点，那就是如何在你工作的文件夹下使用notebook。</p>
<h3 id="1-进入到工作文件夹"><a href="#1-进入到工作文件夹" class="headerlink" title="1. 进入到工作文件夹"></a>1. 进入到工作文件夹</h3><h3 id="2-按住Shift键，然后右击，选择“在此处打开命令窗口”"><a href="#2-按住Shift键，然后右击，选择“在此处打开命令窗口”" class="headerlink" title="2.按住Shift键，然后右击，选择“在此处打开命令窗口”"></a>2.按住<code>Shift</code>键，然后右击，选择“在此处打开命令窗口”</h3><p><img src="https://s1.ax1x.com/2018/12/02/Fu3LtI.png" alt="Fu3LtI.png"></p>
<h3 id="3-输入jupyter-notebook，回车"><a href="#3-输入jupyter-notebook，回车" class="headerlink" title="3.输入jupyter notebook，回车"></a>3.输入jupyter notebook，回车</h3><p><img src="https://s1.ax1x.com/2018/12/02/Fu3j9P.png" alt="Fu3j9P.png"></p>
<h3 id="4-notebook即会在你的默认浏览器中弹出，目录即为该路径下的文件"><a href="#4-notebook即会在你的默认浏览器中弹出，目录即为该路径下的文件" class="headerlink" title="4.notebook即会在你的默认浏览器中弹出，目录即为该路径下的文件"></a>4.notebook即会在你的默认浏览器中弹出，目录即为该路径下的文件</h3><p><strong>注意：</strong>不要关掉弹出notebook的命令窗口，这是将notebook与你电脑内的python链接的纽带。</p>
<p><img src="https://s1.ax1x.com/2018/12/02/Fu89BQ.png" alt="Fu89BQ.png"></p>
<h1 id="Spyder"><a href="#Spyder" class="headerlink" title="Spyder"></a>Spyder</h1><p>我们将会在项目二中用到Spyder这个软件，这个软件也没什么操作难度，所以课程内没有讲解。</p>
<p>我在这里给大家具体讲一下吧。</p>
<h2 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h2><p>Windows用户依次点击<code>开始</code>-<code>所有程序</code>-<code>Anaconda</code>-<code>Spyder</code>即可。</p>
<h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p><img src="https://s1.ax1x.com/2018/12/02/Fu8rCt.png" alt="Fu8rCt.png"></p>
<p>如上，我们可以把Spyder的界面划分为5个部分，分别为：</p>
<p><strong>菜单栏</strong>：就是一些新建、打开、运行、终止等等操作，自行摸索</p>
<p><strong>选择工作区</strong>：这里可以选择工作区路径</p>
<p><strong>代码编辑区</strong>：这里就是你写代码的地方</p>
<p><strong>程序变量/文件路径查看区</strong>：通过选择箭头标注的选项卡，可以显示代码中的变量，或者是当前路径下的文件</p>
<p><strong>控制台</strong>：这里就是显示你代码运行结果的地方，如果代码运行卡住了，可以通过点该区域右上角的<code>■</code>终止运行。</p>
<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><p>先确定工作路径，然后新建脚本，开始编写代码、运行（快捷键F5）、调试。</p>
<p>做完项目二，大家就能熟练操作啦，不要担心~</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/06/2018-10-6-SQL应知应会/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/06/2018-10-6-SQL应知应会/" class="post-title-link" itemprop="url">SQL应知应会</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-06 21:30:09" itemprop="dateCreated datePublished" datetime="2018-10-06T21:30:09+08:00">2018-10-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 12:51:55" itemprop="dateModified" datetime="2019-04-03T12:51:55+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DAND-VIP/" itemprop="url" rel="index"><span itemprop="name">DAND-VIP</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/10/06/2018-10-6-SQL应知应会/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/06/2018-10-6-SQL应知应会/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p> If you want your life to be a magnificent story, then begin by realising that you are the author.</p>
</blockquote>
<p>本文就Udacity数据分析入门课程中的SQL入门（P1阶段）和SQL进阶（P3阶段）的知识点进行总结。SQL的主要功能不外乎<strong>增、删、改、查</strong>四个，对于数据分析师来说，只需要掌握<strong>查</strong>就可以了。（因为增删改往往超出了数据分析师的职能范围）</p>
<blockquote>
<p><strong>注意：</strong>本文是总结性质的，只能提供复习或者速查的功能，讲解得不会很详细，若想学习，还是要在教室内逐章学习。</p>
</blockquote>
<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>SQL是Structured Query Language的简写，也就是<strong>结构化查询语言</strong>。SQL 最受欢迎的功能是与数据库交互。</p>
<p>使用<strong>传统关系数据库</strong>与 SQL 交互有一些主要优点。最明显的 5 个优点是：</p>
<ul>
<li>SQL 很容易理解。</li>
<li>传统的数据库允许我们直接访问数据。</li>
<li>传统的数据库可使我们审核和复制数据。</li>
<li>SQL 是一个可一次分析多个表的很好工具。</li>
<li>相对于 Google Analytics 等仪表板工具，SQL 可使我们分析更复杂的问题。</li>
</ul>
<p><strong>为什么企业喜欢使用数据库</strong></p>
<ol>
<li>只有输入了需要输入的数据，以及只有某些用户能够将数据输入数据库，才能<strong>保证数据的完整性</strong>。</li>
<li><strong>可以快速访问数据</strong> - SQL 可使我们从数据库中快速获取结果。  可以优化代码，快速获取结果。  </li>
<li><strong>可以很容易共享数据</strong> - 多个人可以访问存储在数据库中的数据，所有访问数据库的用户获得的数据都是一样。</li>
</ol>
<p><strong>SQL 与 NoSQL</strong></p>
<p>你可能听说过 NoSQL，它表示 Not only SQL（不仅仅是 SQL）。使用 NoSQL  的数据库时，你编写的数据交互代码会与本节课所介绍的方式有所不同。<strong>NoSQL  更适用于基于网络数据的环境</strong>，而不太适用于我们现在要介绍的基于电子表格的数据分析。最常用的 NoSQL 语言之一是 <a href="https://www.mongodb.com/" target="_blank" rel="noopener">MongoDB</a>。</p>
<h1 id="SQL入门"><a href="#SQL入门" class="headerlink" title="SQL入门"></a>SQL入门</h1><h2 id="SQL书写规则"><a href="#SQL书写规则" class="headerlink" title="SQL书写规则"></a>SQL书写规则</h2><ul>
<li>SQL语句不区分大小写，因此SELECT与select甚至是SeLect的效果是相同的，但是要对命令和变量进行区分，所以默认<strong>命令需要大写，其他内容如变量等则需要小写</strong>；</li>
<li>表和变量名中不要出现空格，可使用下划线<code>_</code>替代。</li>
<li>查询语句中，使用单一空格隔开命令和变量</li>
<li>为提高代码的可移植性，请在查询语句结尾添加一个分号<code>；</code></li>
</ul>
<h2 id="SQL中的注释"><a href="#SQL中的注释" class="headerlink" title="SQL中的注释"></a>SQL中的注释</h2><ul>
<li><p>行内注释</p>
<p>使用两个连字符-，添加注释。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name <span class="comment">-- 这是一条注释</span></span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多行注释</p>
<p>多行注释以<code>/*</code>起始，以<code>*/</code>结尾。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*SELECT col_name </span></span><br><span class="line"><span class="comment">FROM table_name;*/</span></span><br><span class="line"><span class="keyword">SELECT</span> col_2 </span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="检索数据-SELECT-FROM-LIMIT"><a href="#检索数据-SELECT-FROM-LIMIT" class="headerlink" title="检索数据(SELECT FROM LIMIT )"></a>检索数据(SELECT FROM LIMIT )</h2><p>检索数据主要用的语句为：<strong>SELECT</strong>。</p>
<h3 id="检索单列"><a href="#检索单列" class="headerlink" title="检索单列"></a>检索单列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p>从table_name表中检索col_name列。</p>
<h3 id="检索多列"><a href="#检索多列" class="headerlink" title="检索多列"></a>检索多列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1,col_2,col_3</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p>从table_name表中检索col_1,col_2和col_3列。</p>
<h3 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p>使用通配符<code>*</code>，返回table_name表中的所有列；</p>
<h3 id="检索某列中不同的值"><a href="#检索某列中不同的值" class="headerlink" title="检索某列中不同的值"></a>检索某列中不同的值</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col_1</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p>检索col_1中具有唯一性的行，即唯一值。</p>
<h3 id="限制检索的结果"><a href="#限制检索的结果" class="headerlink" title="限制检索的结果"></a>限制检索的结果</h3><p>使用LIMIT语句可以限制返回的行数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>返回前10行（即第0-第9行）。</p>
<p>也可以添加OFFSET语句，设置返回数据的起始行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>从第五行之后，返回十行数据（即第5-第14行）。</p>
<h2 id="排序检索数据-ORDER-BY"><a href="#排序检索数据-ORDER-BY" class="headerlink" title="排序检索数据(ORDER BY)"></a>排序检索数据(ORDER BY)</h2><ul>
<li><p>ORDER BY 语句用于根据指定的单列或多列对结果集进行排序。</p>
</li>
<li><p>ORDER BY 语句默认按照升序对记录进行排序。（从小到大，从a到z）</p>
</li>
<li><p>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。</p>
</li>
<li>在指定一条ORDER BY子句时，应该保证它是SELECT语句中的最后一条子句。</li>
</ul>
<h3 id="按列排序"><a href="#按列排序" class="headerlink" title="按列排序"></a>按列排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col_name;</span><br></pre></td></tr></table></figure>
<p>返回的数据会按照col_name列进行升序排序，这里col_name可以是单列也可以是多列，当然也可以使用非检索的列进行排序。</p>
<h3 id="降序排序"><a href="#降序排序" class="headerlink" title="降序排序"></a>降序排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1,col_2</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col_2 <span class="keyword">DESC</span>,col_3;</span><br></pre></td></tr></table></figure>
<p>返回的数据会按照col_2列降序，col_3列升序对col_1和col_2两列进行排序。</p>
<blockquote>
<p>这里可以看出，DESC关键字的用法：只对跟在语句前面的变量有效。所以，想要对多列进行降序排序时，需要对每一列都指定DESC关键字。</p>
</blockquote>
<h2 id="过滤数据-WHERE"><a href="#过滤数据-WHERE" class="headerlink" title="过滤数据(WHERE)"></a>过滤数据(WHERE)</h2><ul>
<li><p>WHERE子句应该在表名（即FROM子句）之后给出。</p>
</li>
<li><p>WHERE子句应在ORDER BY子句之前。</p>
</li>
<li>在过滤条件中的value是区分大小写的。</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line"><span class="keyword">FROM</span> table_1</span><br><span class="line"><span class="keyword">WHERE</span> col_1 运算符 <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>BETWEEN…AND…</td>
<td>在指定的两值之间</td>
</tr>
<tr>
<td>IS NULL</td>
<td>为NULL值</td>
</tr>
<tr>
<td>AND</td>
<td>逻辑运算符：与</td>
</tr>
<tr>
<td>OR</td>
<td>逻辑运算符：或</td>
</tr>
<tr>
<td>IN</td>
<td>制定条件范围筛选，可以简化OR的工作</td>
</tr>
<tr>
<td>NOT</td>
<td>逻辑运算符：非</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：</p>
<ul>
<li>SQL的版本不同，可能导致某些运算符不同（如不等于可以用！=表示），具体要查阅数据库文档。</li>
<li>在同时输入AND和OR时，SQL会优先处理AND语句，你可以使用小括号来进行分组操作。</li>
</ul>
</blockquote>
<h3 id="用通配符进行过滤（LIKE）"><a href="#用通配符进行过滤（LIKE）" class="headerlink" title="用通配符进行过滤（LIKE）"></a>用通配符进行过滤（LIKE）</h3><p>通配符是用来匹配值的一部分的特殊字符，跟在LIKE关键字后面进行数据过滤</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>%</td>
<td>表示任何字符出现任意次数</td>
</tr>
<tr>
<td>_</td>
<td>表示任何字符出现一次</td>
</tr>
<tr>
<td>[]</td>
<td>指定一个字符集，它必须匹配该位置的一个字符</td>
</tr>
<tr>
<td>^</td>
<td>在[]中使用，表示否定</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line"><span class="keyword">FROM</span> table_1</span><br><span class="line"><span class="keyword">WHERE</span> col_1 <span class="keyword">LIKE</span> <span class="string">'_[^JM]%'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col_1;</span><br></pre></td></tr></table></figure>
<p>如上筛选出的是，第二个字符为非J或M的数据。</p>
<h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><p>其实就是在检索数据的同时进行计算，并使用关键字AS将结果保存为某一列。</p>
<ul>
<li>数值类型的计算</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,quantity,item_price,quantity*item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">200008</span>;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prod_id         quantity       item_price      expanded_price</span><br><span class="line"><span class="comment">--------------------------------------------------------------</span></span><br><span class="line">RGAN01			5				4.9900			24.9500</span><br><span class="line">BR03			5				11.9900			59.9500</span><br></pre></td></tr></table></figure>
<p>这里实现的就是使用quantity*item_price创建一个名为expanded_price的计算字段，也就是一个新列。</p>
<p>同样适用于计算的操作符有<code>+</code>（加），<code>-</code>（减）和<code>/</code>（除）。</p>
<ul>
<li>字符类型的拼接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RTRIM</span>(col_name) + <span class="string">'('</span>+<span class="keyword">RTRIM</span>(col_country)+<span class="string">')'</span> <span class="keyword">AS</span> col_title</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col_name;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">col_title</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line">Bear Emporium(USA)</span><br><span class="line">Bears R Us(USA)</span><br><span class="line">Jouets et ours(France)</span><br></pre></td></tr></table></figure>
<p>这里实现的就是将col_name列与col_country列进行了拼接，新列的名字叫做col_title。</p>
<blockquote>
<p>RTRIM()函数是去掉右边的所有空格，LTRIM()是去掉左边的所有空格，TRIM()是去掉两边的所有空格。</p>
</blockquote>
<h2 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h2><p>在上一节中我们使用AS来为变量设置别名，你可能也见过如下所示的语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 + col2 <span class="keyword">AS</span> total, col3</span><br></pre></td></tr></table></figure>
<p>当然没有 <strong>AS</strong> 的语句也可以实现使用别名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM tablename t1</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 + col2 total, col3</span><br></pre></td></tr></table></figure>
<p>将col1+col2的结果设置名为total的列。</p>
<h2 id="代码总结"><a href="#代码总结" class="headerlink" title="代码总结"></a>代码总结</h2><table>
<thead>
<tr>
<th><strong>语句</strong></th>
<th><strong>使用方法</strong></th>
<th><strong>其他详细信息</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>SELECT <strong>Col1</strong>, <strong>Col2</strong>, …</td>
<td>提供你需要的列</td>
</tr>
<tr>
<td>FROM</td>
<td>FROM <strong>Table</strong></td>
<td>提供列所在的表格</td>
</tr>
<tr>
<td>LIMIT</td>
<td>LIMIT <strong>10</strong></td>
<td>限制返回的行数</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>ORDER BY <strong>Col</strong></td>
<td>根据列命令表格。与 <strong>DESC</strong> 一起使用。</td>
</tr>
<tr>
<td>WHERE</td>
<td>WHERE <strong>Col &gt; 5</strong></td>
<td>用于过滤结果的一个条件语句</td>
</tr>
<tr>
<td>LIKE</td>
<td>WHERE <strong>Col LIKE ‘%me%’</strong></td>
<td>仅提取出列文本中具有 ‘me’ 的行</td>
</tr>
<tr>
<td>IN</td>
<td>WHERE <strong>Col IN (‘Y’, ‘N’)</strong></td>
<td>仅过滤行对应的列为 ‘Y’ 或 ‘N’</td>
</tr>
<tr>
<td>NOT</td>
<td>WHERE <strong>Col NOT IN (‘Y’, “N’)</strong></td>
<td><strong>NOT</strong> 经常与 <strong>LIKE</strong> 和 <strong>IN</strong> 一起使用。</td>
</tr>
<tr>
<td>AND</td>
<td>WHERE <strong>Col1 &gt; 5 AND Col2 &lt; 3</strong></td>
<td>过滤两个或多个条件必须为真的行</td>
</tr>
<tr>
<td>OR</td>
<td>WHERE <strong>Col1 &gt; 5 OR Col2 &lt; 3</strong></td>
<td>过滤一个条件必须为真的行</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>WHERE <strong>Col BETWEEN 3 AND 5</strong></td>
<td>一般情况下，语法比使用 <strong>AND</strong> 简单一些</td>
</tr>
</tbody>
</table>
<h1 id="SQL进阶"><a href="#SQL进阶" class="headerlink" title="SQL进阶"></a>SQL进阶</h1><h2 id="链接表"><a href="#链接表" class="headerlink" title="链接表"></a>链接表</h2><h3 id="基本链接（JOIN）"><a href="#基本链接（JOIN）" class="headerlink" title="基本链接（JOIN）"></a>基本链接（JOIN）</h3><p>SQL最强大的功能之一就是能在数据查询的执行中进行表的链接（JOIN）。</p>
<p>在关系数据库中，将数据分解为多个表能更有效地存储，更方便地处理，但这些数据储存在多个表中，怎样用一条SELECT语句就检索出数据呢？那就要使用链接。</p>
<p>创建链接的方式很简单，如下便是使用WHERE创建链接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1,col_2,col_3</span><br><span class="line"><span class="keyword">FROM</span> table_1,table_2</span><br><span class="line"><span class="keyword">WHERE</span> table_1.id = table2.id;</span><br></pre></td></tr></table></figure>
<p>如上，col_1和col_2属于table_1表中，col_3属于table_2表中，而这两个表使用相同的id列进行匹配。这种方法被称为等值链接，也就是内链接，我们可以使用如下的语句，更直观地实现内连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1,col_2,col_3</span><br><span class="line"><span class="keyword">FROM</span> table_1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table_2</span><br><span class="line"><span class="keyword">ON</span> table_1.id = table2.id;</span><br></pre></td></tr></table></figure>
<p>当然你也可以使用别名，简化输入，并且标明各列与表的隶属关系：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.col_1,t1.col_2,t2.col_3</span><br><span class="line"><span class="keyword">FROM</span> table_1 t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table_2 t2</span><br><span class="line"><span class="keyword">ON</span> t1.id = t2.id;</span><br></pre></td></tr></table></figure>
<p>如上代码同样适用于左链接、右链接和外链接：</p>
<ul>
<li><p><strong>LEFT JOIN</strong> - 用于获取 <strong>FROM</strong> 中的表格中的所有行，即使它们不存在于 <strong>JOIN</strong> 语句中。</p>
</li>
<li><p><strong>RIGHT JOIN</strong> - 用于获取 <strong>JOIN</strong> 中的表格中的所有行，即使它们不存在于 <strong>FROM</strong> 语句中。</p>
</li>
<li><strong>FULL JOIN</strong>: 只要其中一个表中存在匹配，就返回行。</li>
</ul>
<h3 id="自链接"><a href="#自链接" class="headerlink" title="自链接"></a>自链接</h3><p>自链接经常用于对子查询的简化，如下示例：</p>
<p>假如要给Jim同一公司的所有顾客发送一封邮件，需要你先筛选出Jim的公司，然后再根据该公司筛选出所有的顾客。使用子查询的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id,cust_name,cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name = (<span class="keyword">SELECT</span> cust_name</span><br><span class="line">                  <span class="keyword">FROM</span> customers</span><br><span class="line">                  <span class="keyword">WHERE</span> cust_contact = <span class="string">'Jim'</span>)</span><br></pre></td></tr></table></figure>
<p>如果改为自链接的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1.cust_id,c1.cust_name,c1.cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers c1,customers c2</span><br><span class="line"><span class="keyword">WHERE</span> c1.cust_name = c2.cust_name</span><br><span class="line"><span class="keyword">AND</span> c2.cust_name = <span class="string">'Jim'</span>;</span><br></pre></td></tr></table></figure>
<p>结果是一样的，但是使用自链接的处理速度比子查询要快得多。</p>
<h3 id="组合查询（UNION）"><a href="#组合查询（UNION）" class="headerlink" title="组合查询（UNION）"></a>组合查询（UNION）</h3><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集，使用方法也很简单，只要在多条SELECT语句中添加UNION关键字即可。</p>
<blockquote>
<p>多数情况下，组合相同表的多个查询所完成的任务与具有多个WHERE子句的一个查询是一样的。</p>
</blockquote>
<p><strong>注意</strong>：UNION 内部的 SELECT 语句必须拥有相同数量的列，列也必须拥有相似的数据类型。而且UNION返回的结果只会选取不同的值（即唯一值）。</p>
<p>使用UNION的场合情况：</p>
<ul>
<li>在一个查询中从不同的表返回结果；</li>
<li>对一个表执行多个查询返回结果。</li>
</ul>
<p>示例：如下三个语句的结果是一致的。</p>
<ul>
<li>原始语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询一</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name,cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">IN</span> (<span class="string">'str1'</span>,<span class="string">'str2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询二</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name,cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name = <span class="string">'str3'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用UNION链接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">IN</span> (<span class="string">'str1'</span>,<span class="string">'str2'</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name,cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name = <span class="string">'str3'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>
<p>在最后添加了ORDER BY对所有SELECT语句进行排序，这里只是为了示例在使用UNION时如何进行排序。</p>
<ul>
<li>使用WHERE</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">IN</span> (<span class="string">'str1'</span>,<span class="string">'str2'</span>)</span><br><span class="line"><span class="keyword">OR</span> cust_name = <span class="string">'str3'</span>;</span><br></pre></td></tr></table></figure>
<p>这里看起来使用UNION比WHERE更复杂，但对于较复杂的筛选条件，或者从多个表中检索数据时，使用UNION更简单一些。</p>
<ul>
<li><strong>UNION ALL</strong> 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值。</li>
</ul>
<h2 id="SQL聚合"><a href="#SQL聚合" class="headerlink" title="SQL聚合"></a>SQL聚合</h2><p>有时候我们只是需要获取数据的汇总信息，比如说行数啊、平均值啊这种，并不需要吧所有数据都检索出来，为此，SQL提供了专门的函数，这也是SQL最强大功能之一。</p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>SQL的聚合函数如下所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVG()</td>
<td>返回某列的均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>返回某列的行数</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列的和</td>
</tr>
</tbody>
</table>
<p>使用示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(col_1) <span class="keyword">AS</span> avg_col_1</span><br><span class="line"><span class="keyword">FROM</span> table_1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>聚合函数都会忽略列中的NULL值，但是COUNT(*)也就是统计全部数据的行数时，不会忽略NULL值。</p>
</blockquote>
<h3 id="聚合不同值"><a href="#聚合不同值" class="headerlink" title="聚合不同值"></a>聚合不同值</h3><p>当添加DISTINCT参数时，就可以只对不同值（也就是某列中的唯一值）进行函数操作。</p>
<p>使用示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> col_1) <span class="keyword">AS</span> avg_col_1</span><br><span class="line"><span class="keyword">FROM</span> table_1;</span><br></pre></td></tr></table></figure>
<h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><h3 id="创建分组（GROUP-BY）"><a href="#创建分组（GROUP-BY）" class="headerlink" title="创建分组（GROUP BY）"></a>创建分组（GROUP BY）</h3><p>前面的函数操作都是基于整个表去进行的，那如果想要依据某列中的不同类别（比如说不同品牌 不同性别等等）进行分类统计时，就要用到数据分组，在SQL中数据分组是使用GROUP BY子句建立的。</p>
<p>在使用GROUP BY时需要注意的几点：</p>
<ul>
<li>GROUP BY子句可以包含任意数量的列，因而可以对分组进行多重嵌套，类似于Pandas中的多重索引；</li>
<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY之前。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_col</span><br><span class="line"><span class="keyword">FROM</span> table_1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col_1;</span><br></pre></td></tr></table></figure>
<p>以上即可实现按col_1列中的不同类目进行行数统计。</p>
<h3 id="过滤分组（HAVING）"><a href="#过滤分组（HAVING）" class="headerlink" title="过滤分组（HAVING）"></a>过滤分组（HAVING）</h3><p>在SQL入门中我们学过WHERE，它是对行数据进行筛选过滤的，那么，如果我想对创建的分组数据进行筛选过滤呢？这时候，你就要用到HAVING子句了，它与WHERE的操作符一致，只是换了关键字而已。</p>
<p>使用示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_col</span><br><span class="line"><span class="keyword">FROM</span> table_1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col_1</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>这里我们就筛选出了具有两个以上类别的分组。</p>
<p><strong>注意：</strong>使用HAVING时应该结合GROUP BY子句。</p>
<h2 id="时间序列的处理（DATE）"><a href="#时间序列的处理（DATE）" class="headerlink" title="时间序列的处理（DATE）"></a>时间序列的处理（DATE）</h2><p>在SQL中有一套专门的内置函数，用来处理时间序列，那就是DATE函数。</p>
<h3 id="SQL-Date-数据类型"><a href="#SQL-Date-数据类型" class="headerlink" title="SQL Date 数据类型"></a>SQL Date 数据类型</h3><p>先了解一下在不同的数据库中的时间序列的表示。（了解即可）</p>
<p><strong>MySQL</strong> 使用下列数据类型在数据库中存储日期或日期/时间值：</p>
<ul>
<li>DATE - 格式：YYYY-MM-DD</li>
<li>DATETIME - 格式：YYYY-MM-DD HH:MM:SS</li>
<li>TIMESTAMP - 格式：YYYY-MM-DD HH:MM:SS</li>
<li>YEAR - 格式：YYYY 或 YY</li>
</ul>
<p><strong>SQL Server</strong> 使用下列数据类型在数据库中存储日期或日期/时间值：</p>
<ul>
<li>DATE - 格式：YYYY-MM-DD</li>
<li>DATETIME - 格式：YYYY-MM-DD HH:MM:SS</li>
<li>SMALLDATETIME - 格式：YYYY-MM-DD HH:MM:SS</li>
<li>TIMESTAMP - 格式：唯一的数字</li>
</ul>
<h3 id="DATE-TRUNC函数"><a href="#DATE-TRUNC函数" class="headerlink" title="DATE_TRUNC函数"></a>DATE_TRUNC函数</h3><p><strong>DATE_TRUNC</strong> 使你能够将日期截取到日期时间列的特定部分。常见的截取依据包括<code>日期</code>、<code>月份</code> 和 <code>年份</code>。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATE_TRUNC('datepart', timestamp)</span><br></pre></td></tr></table></figure>
<p>其中<code>datepart</code>即为你的截取依据，后面的timestamp类型可以参考上面的Date数据类型。</p>
<blockquote>
<p> 我总结了一份SQL的<code>datepart</code>速查表放在了下面。</p>
</blockquote>
<p>使用示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_TRUNC(<span class="string">'y'</span>,col_date) col_year</span><br><span class="line"><span class="keyword">FROM</span> table_1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">1</span> <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>如上，我们将col_date列按照年（’y’）进行了分组，并按由大至小的顺序排序，取前10组数据。</p>
<h3 id="DATE-PART函数"><a href="#DATE-PART函数" class="headerlink" title="DATE_PART函数"></a>DATE_PART函数</h3><p><strong>DATE_PART</strong> 可以用来获取日期的特定部分，如获取日期2018-10-6的月份，只会获得一个结果6，这是它与DATE_TRUNC的最大区别。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATE_PART ('datepart', date或timestamp)</span><br></pre></td></tr></table></figure>
<p>其中<code>datepart</code>即为你的截取依据，后面的timestamp类型可以参考上面的Date数据类型。</p>
<p>使用示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_PART(<span class="string">'y'</span>,col_date) col_year</span><br><span class="line"><span class="keyword">FROM</span> table_1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如上，我们筛选了col_date列的年份，并依据它做了分组。</p>
<blockquote>
<p>想了解更多DATE函数，可以戳<a href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/Date_functions_header.html" target="_blank" rel="noopener">SQL日期和时间函数参考</a></p>
</blockquote>
<h3 id="datepart总结"><a href="#datepart总结" class="headerlink" title="datepart总结"></a>datepart总结</h3><p>如下给了很多的缩写，只记住最简单的即可。</p>
<table>
<thead>
<tr>
<th>日期部分或时间部分</th>
<th style="text-align:left">缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>世纪</td>
<td style="text-align:left">c、cent、cents</td>
</tr>
<tr>
<td>十年</td>
<td style="text-align:left">dec、decs</td>
</tr>
<tr>
<td>年</td>
<td style="text-align:left">y、yr、yrs</td>
</tr>
<tr>
<td>季度</td>
<td style="text-align:left">qtr、qtrs</td>
</tr>
<tr>
<td>月</td>
<td style="text-align:left">mon、mons</td>
</tr>
<tr>
<td>周</td>
<td style="text-align:left">w，与 <strong>DATE_TRUNC</strong>一起使用时将返回离时间戳最近的一个星期一的日期。</td>
</tr>
<tr>
<td>一周中的日 （ <strong>DATE_PART</strong>支持）</td>
<td style="text-align:left">dayofweek、dow、dw、weekday                                                                                                              返回 0–6 的整数（星期日是0，星期六是6）。</td>
</tr>
<tr>
<td>一年中的日 （ <strong>DATE_PART</strong>支持）</td>
<td style="text-align:left">dayofyear、doy、dy、yearday</td>
</tr>
<tr>
<td>日</td>
<td style="text-align:left">d</td>
</tr>
<tr>
<td>小时</td>
<td style="text-align:left">h、hr、hrs</td>
</tr>
<tr>
<td>分钟</td>
<td style="text-align:left">m、min、mins</td>
</tr>
<tr>
<td>秒</td>
<td style="text-align:left">s、sec、secs</td>
</tr>
<tr>
<td>毫秒</td>
<td style="text-align:left">ms、msec、msecs、msecond、mseconds、millisec、millisecs、millisecon</td>
</tr>
</tbody>
</table>
<h2 id="CASE语句"><a href="#CASE语句" class="headerlink" title="CASE语句"></a>CASE语句</h2><p>CASE语句其实就相当于python中的if语句，是用来做条件的。</p>
<p>需要注意的几点：</p>
<ul>
<li>CASE 语句始终位于 SELECT 条件中。</li>
<li>CASE 必须包含以下几个部分：WHEN、THEN 和 END。ELSE 是可选组成部分，用来包含不符合上述任一 CASE 条件的情况。</li>
<li>你可以在 WHEN 和 THEN 之间使用任何条件运算符编写任何条件语句（例如 WHERE），包括使用 AND 和 OR 连接多个条件语句。</li>
<li>你可以再次包含多个 WHEN 语句以及 ELSE 语句，以便处理任何未处理的条件。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> account_id, <span class="keyword">CASE</span> <span class="keyword">WHEN</span> standard_qty = <span class="number">0</span> <span class="keyword">OR</span> standard_qty <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="number">0</span></span><br><span class="line">                        <span class="keyword">ELSE</span> standard_amt_usd/standard_qty <span class="keyword">END</span> <span class="keyword">AS</span> unit_price</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>如上，我们使用CASE WHEN.(条件一).THEN.(条件一的结果).ELSE.(其他不符合条件一的结果).END语句，设立的两个条件，即当standard_qty为0或者不存在时我们返回0，当standard_qty不为0时进行计算，并储存为新列unit_price。</p>
<h2 id="子查询与临时表格"><a href="#子查询与临时表格" class="headerlink" title="子查询与临时表格"></a>子查询与临时表格</h2><p>我们之前所涉及到的都是从数据库表中检索数据的单条语句，但当我们想要检索的数据并不能直接从数据库表中获取，而是需要从筛选后的表格中再度去查询时，就要用到子查询和临时表格了。</p>
<p>子查询与临时表格所完成的任务是一致的，只不过子查询是通过嵌套查询完成，而另一种是通过WITH创建临时表格进行查询。</p>
<h3 id="构建子查询"><a href="#构建子查询" class="headerlink" title="构建子查询"></a>构建子查询</h3><p>构建子查询十分简单，只需将被查询的语句放在小括号里，进行嵌套即可，但在使用时一定要注意格式要清晰。</p>
<p>使用示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> DATE_TRUNC(<span class="string">'day'</span>,occurred_at) <span class="keyword">AS</span> <span class="keyword">day</span>,channel, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">events</span></span><br><span class="line">      <span class="keyword">FROM</span> web_events </span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">3</span> <span class="keyword">DESC</span>) sub</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> channel</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>如上，我们创建了一个子查询，放在小括号里，并将其命名为sub。在子查询中也注意到了各个子句上下对齐，这样条例更清晰。</p>
<h3 id="临时表格（WITH）"><a href="#临时表格（WITH）" class="headerlink" title="临时表格（WITH）"></a>临时表格（WITH）</h3><p>这种方法，就是使用WITH将子查询的部分创建为一个临时表格，然后再进行查询即可。</p>
<p>我们还是使用上面子查询的例子，这次用临时表格的形式实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> sub <span class="keyword">AS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> DATE_TRUNC(<span class="string">'day'</span>,occurred_at) <span class="keyword">AS</span> <span class="keyword">day</span>,channel, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">events</span></span><br><span class="line"><span class="keyword">FROM</span> web_events </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">3</span> <span class="keyword">DESC</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> sub</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> channel</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>如上，我们将被嵌套的子查询单独拎出来，用WITH创建了一个临时表格，再之后又使用SELECT根据该表格进行查询。</p>
<h2 id="SQL数据清理"><a href="#SQL数据清理" class="headerlink" title="SQL数据清理"></a>SQL数据清理</h2><p>这一节主要针对数据清理讲解了几个SQL中的常用函数，一般来说，也都是用在筛选阶段，更详尽的数据清理还是要放在python中去进行。</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul>
<li><strong>LEFT、RIGHT、LENGTH</strong></li>
</ul>
<p>LEFT和RIGHT相当于是字符串截取，<strong>LEFT</strong> 是从左侧起点开始，从特定列中的每行获取一定数量的字符，而<strong>RIGHT</strong>是从右侧。</p>
<p><strong>LENGTH</strong>就是获取字符串的长度，相当于python中的len()。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEFT(phone_number, 3) <span class="comment">-- 返回从左侧数，前三个字符</span></span><br><span class="line">RIGHT(phone_number, 8)</span><br><span class="line">LENGTH(phone_number)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>POSITION</strong>、<strong>STRPOS</strong>、<strong>SUBSTR</strong></li>
</ul>
<p>这三个函数都是与<strong>位置</strong>相关的函数。</p>
<p><strong>POSITION</strong> 和<strong>STRPOS</strong> 可以获取某一字符在字符串中的位置，这个位置是从左开始计数，最左侧第一个字符位置为1，但他俩的语法稍有不同。</p>
<p><strong>SUBSTR</strong>可以筛选出指定位置后指定数量的字符。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POSITION(',' IN city_state)</span><br><span class="line">STRPOS(city_state, ‘,’) <span class="comment">--跟上面的语句等价</span></span><br><span class="line">SUBSTR(city_state,4,5) <span class="comment">-- 返回city_state字符串中，以第4个字符开头的5个字符。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>字符串拼接（CONCAT）</strong></li>
</ul>
<p>顾名思义，就是将两个字符串进行拼接。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(first_name, ' ', last_name) <span class="comment">-- 结果为：first_name last_name</span></span><br><span class="line"><span class="comment">--或者你也可以使用双竖线来实现上述任务</span></span><br><span class="line">first_name || ' ' || last_name</span><br></pre></td></tr></table></figure>
<h3 id="更改数据格式"><a href="#更改数据格式" class="headerlink" title="更改数据格式"></a>更改数据格式</h3><ul>
<li>TO_DATE函数</li>
</ul>
<p>TO_DATE函数可以将某列转为DATE格式，主要是将单独的月份或者年份等等转换为SQL可以读懂的DATE类型数据。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TO_DATE(col_name,'datepart') </span><br><span class="line">TO_DATE('02 Oct 2001', 'DD Mon YYYY');</span><br></pre></td></tr></table></figure>
<p>这里是将col_name这列按照datepart转化为DATE类型的数据，datepart可以参考之前的总结。</p>
<ul>
<li>CAST函数</li>
</ul>
<p>CAST函数是SQL中进行数据类型转换的函数，但经常用于将字符串类型转换为时间类型。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CAST(date_column AS DATE)</span><br><span class="line"><span class="comment">-- 你也可以写成这样</span></span><br><span class="line">date_column::DATE</span><br></pre></td></tr></table></figure>
<p>这里是将date_column转换为DATE格式的数据，其他时间相关的数据类型与样式对照可以参考上面写过的<strong>SQL Date数据类型</strong>，确保你想转换的数据样式与数据类型对应。</p>
<h3 id="缺失值的处理"><a href="#缺失值的处理" class="headerlink" title="缺失值的处理"></a>缺失值的处理</h3><p>之前有提到过如何筛选出缺失值，即使用<strong>WHERE</strong>加上<strong>IS NULL</strong>或者<strong>IS NOT NULL</strong>。</p>
<p>那么如何对缺失值进行处理呢？（其实这里可以直接无视，筛选出来后在python中再进行处理）</p>
<p>SQL中提供了一个替换NULL值的函数<strong>COALESCE</strong>。</p>
<p>使用示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COALESCE(col_1,0) <span class="comment">-- 将col_1中的NULL值替换为0</span></span><br><span class="line">COALESCE(col_2,'no DATA') <span class="comment">-- 将col_2中的NULL值替换为no DATA</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好啦，至此课程中的所有SQL知识点已经总结完了，并且也给大家做了适当的补充，希望大家能够用得上。未来的数据分析师之路，还要继续加油呀！</p>
<p><img src="http://wx4.sinaimg.cn/bmiddle/006Cmetyly1fmtcyy5h20j30dw0dwaiw.jpg" alt></p>
<h1 id="附：SELECT子句顺序"><a href="#附：SELECT子句顺序" class="headerlink" title="附：SELECT子句顺序"></a>附：SELECT子句顺序</h1><p>下表中列出了全文中涉及到的子句，在进行使用时，应严格遵循下表中从上至下的顺序。</p>
<table>
<thead>
<tr>
<th>子句</th>
<th>说明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>用于检索数据的表</td>
<td>仅在从表中选择数据时使用</td>
</tr>
<tr>
<td>JOIN…ON…</td>
<td>用于链接表</td>
<td>仅在需要链接表时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td>过滤行数据</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组数据</td>
<td>仅在按组计算时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td>过滤分组</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>对输出进行排序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>限制输出的行数</td>
<td>否</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/26/2018-9-26-第十二周-项目四/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/09/26/2018-9-26-第十二周-项目四/" class="post-title-link" itemprop="url">每周导学-第十二周-项目四</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-26 22:30:09" itemprop="dateCreated datePublished" datetime="2018-09-26T22:30:09+08:00">2018-09-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 12:51:55" itemprop="dateModified" datetime="2019-04-03T12:51:55+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DAND-VIP/" itemprop="url" rel="index"><span itemprop="name">DAND-VIP</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/09/26/2018-9-26-第十二周-项目四/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/09/26/2018-9-26-第十二周-项目四/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p> Better together . —— Udacity</p>
</blockquote>
<p>Hi，同学们，经过前两周的学习，我们掌握了描述统计学基础、概率论基础、推论统计学中的置信区间、假设检验以及机器学习入门知识——回归，本章的内容偏理论性更多一些，需要更多得去实操来加强自己的理解能力，这周呢我们就来个实打实的项目来检验前两周的所学。项目为<strong>分析A/B测试结果</strong>，在开始项目前，请一定要把前面的几个小测试做了，这样做项目更好上手一些。大家加油！通过这个项目，就可以拿到入门的毕业证啦！！！</p>
<p><strong>项目四(P4)阶段</strong>总共包含<strong>三周</strong>，在这三周内，我们要对<strong>统计学</strong>进行学习，掌握基础的<strong>描述统计学理论、基本的概率知识、二项分布和贝叶斯公式</strong>，并学会<strong>使用 Python 来实践</strong>；学习<strong>正态分布、抽样分布、置信区间以及假设检验的概念和计算方式</strong>；学习<strong>线性回归以及逻辑回归</strong>，在真实场景中应用，比如<strong>分析 A/B 测试</strong>结果，搭建简单的监督机器学习模型。可谓是时间紧任务重，但是也别怕，统计学的基础知识还是非常简单的，跟着课程内容一步步来，自己多做笔记多查资料，一定没问题的！</p>
<p>那么我们的课程安排：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>学习重点</th>
<th>对应课程</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1周</td>
<td>统计学基础</td>
<td>描述统计学 - 抽样分布与中心极限定理</td>
</tr>
<tr>
<td>第2周</td>
<td>统计学进阶</td>
<td>置信区间 - 逻辑回归</td>
</tr>
<tr>
<td><strong>第3周</strong></td>
<td><strong>完成项目</strong></td>
<td><strong>项目：分析A/B测试结果</strong></td>
</tr>
</tbody>
</table>
<p>本阶段可能是个挑战，请一定要<strong>保持自信</strong>，请一定要坚持<strong>学习和总结</strong>，如果遇到任何<strong>课程问题</strong>请参照如下顺序进行解决：</p>
<ul>
<li>先自行查找问题答案（注意提取关键词），参考：谷歌/必应搜索、<a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a>、<a href="https://stackoverflow.com/" target="_blank" rel="noopener">stack<strong>overflow</strong></a></li>
<li>额外参考资料：<ul>
<li><a href="https://www.khanacademy.org/math/statistics-probability" target="_blank" rel="noopener">可汗学院概率论与统计课程</a></li>
<li><a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/%E6%9C%BA%E4%BC%9A%E7%9A%84%E6%95%B0%E5%AD%A6-%E9%99%88%E5%B8%8C%E5%AD%BA.pdf" target="_blank" rel="noopener">机会的数学-陈希孺</a></li>
<li><a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87%E5%8F%8A%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F%E5%8F%8A%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F.pdf" target="_blank" rel="noopener">条件概率及全概率公式及贝叶斯公式</a></li>
<li><a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/statistics%20for%20data%20science.pdf" target="_blank" rel="noopener">statistics for data science</a></li>
</ul>
</li>
<li>若问题未解决，请将<strong>问题</strong>及其<strong>所在课程章节</strong>发送至微信群，并@助教即可</li>
</ul>
<p>饭要一口一口吃，路要一步一步走，大家不要被任务吓到，跟着导学一步一步来，肯定没问题哒！那我们开始吧！</p>
<blockquote>
<p><strong>注：</strong>本着<strong>按需知情</strong>原则，所涉及的知识点都是在数据分析过程中必须的、常用的，而不是最全面的，想要更丰富，那就需要你们课下再进一步的学习和探索！</p>
</blockquote>
<h1 id="本周目标"><a href="#本周目标" class="headerlink" title="本周目标"></a>本周目标</h1><p>完成并通过项目四！</p>
<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><table>
<thead>
<tr>
<th>时间</th>
<th>学习资源</th>
<th>学习内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>周二</td>
<td>微信群 - 每周导学</td>
<td>预览每周导学</td>
</tr>
<tr>
<td>周三、周四</td>
<td>Udacity - Classroom</td>
<td>项目四</td>
</tr>
<tr>
<td>周五</td>
<td>微信/Classin - 1V1</td>
<td>课程难点</td>
</tr>
<tr>
<td>周六</td>
<td>Classin - 优达日</td>
<td>本周学习总结、答疑</td>
</tr>
<tr>
<td>周日</td>
<td>笔记本</td>
<td>总结沉淀</td>
</tr>
<tr>
<td>周一</td>
<td>自主学习</td>
<td>查漏补缺</td>
</tr>
</tbody>
</table>
<h1 id="项目指南"><a href="#项目指南" class="headerlink" title="项目指南"></a>项目指南</h1><h2 id="项目详情"><a href="#项目详情" class="headerlink" title="项目详情"></a>项目详情</h2><p>数据分析师和数据学家经常使用 A/B 测试。在这个项目中，你将会理解电子商务网站运营 A/B 测试的结果。你的目标是通过课程中给的Jupyter Notebook，帮助公司理解他们是否应该设计新页面、保留原有网页或延长测试时间以便做出决定。</p>
<p>项目前面的几个小测试，需要大家针对项目提供的数据进行操作并回答，你可以打开两个网页，也可以在本地进行操作。</p>
<blockquote>
<p>当然还是建议大家下载到本地进行操作，如果文件下载失败，请微信联系我。</p>
</blockquote>
<blockquote>
<p>关于A/B-test:</p>
<p><strong>AB 测试</strong>就是为了验证在先验条件的存在的情况下，进行新的变更是否合理和可行以达到优化的目的。使用 AB 测试的方式能能够度量变更对某些指标的变化，是变更更具有合理性依据更充分。</p>
<p>AB 测试也存在 <strong>不适用的场景</strong>：1）对没有明确参照的试验，AB 测试是基于先验条件的优化，如果没有一个参照对比是无法进行测试。2）数据获取时间长，AB 测试一般都是进行小规模快速的试验，所以对于数据获取的单周期较长的试验不太适用。</p>
<p>影响测试效果的因素：1）<strong>新奇效应</strong>：即<code>Novelty Effect</code> 指老用户可能会觉得变化很新鲜，受变化吸引而偏爱新版本，哪怕从长远看来新版本并无益处。2）<strong>抗拒改变心理</strong>：即 <code>Change Aversion</code> 老用户可能会因为纯粹不喜欢改变而偏爱旧版本，哪怕从长远来看新版本更好。</p>
</blockquote>
<p>在课程项目中，我们分成了三块涵盖了本章的所有知识点，这三块分别为：</p>
<ul>
<li>概率</li>
<li>A/B测试</li>
<li>回归</li>
</ul>
<p>如果在项目进行中，有知识点遗漏或忘记的地方，可以去查看相关课程视频或者导学，之后，记在你的小本本上。</p>
<h2 id="I-概率"><a href="#I-概率" class="headerlink" title="I - 概率"></a>I - 概率</h2><p>本节的问题都相对比较简单，所以在导学中不过多赘述了。</p>
<h3 id="测试1-理解数据集"><a href="#测试1-理解数据集" class="headerlink" title="测试1-理解数据集"></a>测试1-理解数据集</h3><p>这里没什么难度，基本的pandas知识，如果这节有什么问题的话，请查看<a href="http://www.capallen.top/dand-vip/2018/08/19/%E7%AC%AC%E5%85%AD%E5%91%A8-1-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">第六周导学</a>并面壁十分钟-。-</p>
<blockquote>
<p>如果非要提醒一下的话，那就是在问题<strong>e.  <code>new_page</code> 与 <code>treatment</code> 不一致的次数</strong>中，不要忘了也看看old_page与control的不一致次数，二者相加才是结果。</p>
</blockquote>
<h3 id="测试3-更新后的数据集"><a href="#测试3-更新后的数据集" class="headerlink" title="测试3-更新后的数据集"></a>测试3-更新后的数据集</h3><ul>
<li>a问题中，因为要将处理后的数据集保存为新的变量，所以使用drop函数时，可以不用使用inplace = True参数。</li>
<li>d问题中，因为两个重复值除了时间戳不一致外，其他信息都是一致的，所以随便删除一个重复即可。</li>
</ul>
<h2 id="II-A-B测试"><a href="#II-A-B测试" class="headerlink" title="II - A/B测试"></a>II - A/B测试</h2><h3 id="1-零假设与备择假设"><a href="#1-零假设与备择假设" class="headerlink" title="1.零假设与备择假设"></a>1.零假设与备择假设</h3><p>这里只说一点，就是如何在Jupyter Notebook中使用公式的问题，其实也就是如何在Markdown中使用公式的问题，你只需要按照如下步骤即可：</p>
<ul>
<li><p>打开<a href="http://latex.codecogs.com/eqneditor/editor.php" target="_blank" rel="noopener">Latex公式在线转换</a>，输入好公式后，复制代码</p>
</li>
<li><p>将你想要输入公式的代码框，转为Markdown格式；</p>
</li>
<li><p>输入两个美元符号，即$$;</p>
</li>
<li><p>将刚复制的公式代码粘贴到两个美元符号中间，然后运行该代码框即可。</p>
<p>录了一个gif在下面，可以参考下：</p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/09/26/iMRliF.gif" alt="iMRliF.gif"></p>
<h3 id="2-进行假设检验"><a href="#2-进行假设检验" class="headerlink" title="2.进行假设检验"></a>2.进行假设检验</h3><ul>
<li>a、b</li>
</ul>
<p>注意题干中给的要求是：假定在零假设中，不管是新页面还是旧页面， pnew 和 pold 都具有等于 <strong>转化</strong> 成功率的“真”成功率，也就是说，  pnew 与 pold是相等的。此外，假设它们都等于<strong>ab_data.csv</strong> 中的 <strong>转化</strong> 率，新旧页面都是如此。</p>
<p>也就是：p_new = p_old = p_ab_data</p>
<blockquote>
<p><strong>注意：</strong>这并不意味着零假设就是p_new = p_old，可以从后续的c-g步骤能看出，零假设为p_new - p_old ≤ 0</p>
</blockquote>
<ul>
<li>c、d</li>
</ul>
<p>这里的n_new与n_old就是对ab_data中使用新旧页面的<strong>用户数量</strong>进行统计。</p>
<ul>
<li>e、f、g</li>
</ul>
<p>使用numpy.random.choice函数，将零假设中的p_new与p_old作为抽样概率，n_new与n_old作为抽样次数，用1表示‘转化成功’，0表示‘未转化成功’，并将结果储存在一个新变量当中。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_page_converted = np.random.choice([<span class="number">0</span>,<span class="number">1</span>],n_new,p = [<span class="number">1</span>-p_new,p_new])</span><br></pre></td></tr></table></figure>
<p>以上获得的这个新变量，就是我们按照零假设中的n_new抽样n_new次的转化与否的分布模拟，那如何看模拟后的转化率呢？很简单，一个函数就搞定了，这里自己想。</p>
<ul>
<li>h、i、j</li>
</ul>
<p>这三步是使用for循环，将上面的过程不断重复10000次，获得一个抽样分布直方图，这个图会是正态分布吗？</p>
<p>关于实际观测值，即为你利用ab_data.csv直接计算得来的new_page与old_page转化率之差。</p>
<p>j中得到的值是什么呢？是不是在零假设的条件下，观察到实际观测值甚至更极端（更支持备择假设）的概率？那这个值的学名叫什么？</p>
<p>【这里实际上进行的是单尾检验，也就是对备择假设为p_new - p_old &gt; 0来进行的】</p>
<ul>
<li>i、m</li>
</ul>
<p>使用了statsmodels中的proportions_ztest函数进行检验。实现的功能和上述a-j是一致的。</p>
<p>为什么要选择这个函数，以及这个函数的用法可以参考课程中给的链接<a href="http://knowledgetack.com/python/statsmodels/proportions_ztest/" target="_blank" rel="noopener">proportions_ztest</a>。</p>
<p>不过值得注意的是，在链接的列子中，使用的是双尾检验，也就是针对备择假设为p_new ≠ p_old去做的；但是在课程项目中，我们的备择假设为p_new &gt; p_old，也就是单尾检验，所以函数中的某个参数要改一下。</p>
<p>使用内置函数方法获得的p值应该与前面获得的p值相近，如果差太多，那肯定是有地方需要再琢磨琢磨。</p>
<h2 id="III-回归"><a href="#III-回归" class="headerlink" title="III - 回归"></a>III - 回归</h2><ul>
<li>a</li>
</ul>
<p>要想知道执行哪种类型的回归，就应该先看变量是属于数值变量还是分类变量，那题设中的变量是什么类型的变量呢？</p>
<ul>
<li>b</li>
</ul>
<p>要求是：创建一个 <strong>ab_page</strong> 列，当用户接收 <strong>treatment</strong> 时为1， <strong>control</strong> 时为0。所以在对group列使用get_dummies函数时，应该把生成的treatment列保存为ab_page列，而control列则应该被删掉。</p>
<ul>
<li>c、d</li>
</ul>
<p>注意的一点是：<strong>不要忘了添加截距。</strong>在进行结果解释的时候，我们并不关注截距，只是关注变量的coef系数和p值，先看p值是否具有显著性，若有再看coef系数，若没有，则该变量对因变量没有影响。</p>
<ul>
<li>e</li>
</ul>
<p>在思考零假设与备择假设之前，注意看结果中标红框的位置，想想这是什么意思，这说明在回归计算中，采用的是单尾检验还是双尾？单尾和双尾又分别对应的假设是什么？</p>
<p><img src="https://s1.ax1x.com/2018/09/27/iQQBSs.png" alt="iQQBSs.png"></p>
<ul>
<li>g</li>
</ul>
<p><strong>数据集融合问题</strong>，之前单独出过一篇导学，如果忘了，请戳：<a href="http://www.capallen.top/dand-vip/2018/08/21/%E7%AC%AC%E5%85%AD%E5%91%A8-2-%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88/" target="_blank" rel="noopener">Pandas数据融合</a>，提醒下，合并时采用内连接，可以省去一些麻烦；</p>
<p><strong>get_dummies</strong>，注意该函数生成数据的顺序是按照字典顺序来的，所以，你在进行操作时，为了确保顺序不乱，最好能先看一下生成的结果，再进行重命名。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大家能坚持到最后一个项目，十分不易，不过对于数据分析生涯来说，这只是你的开始，请继续保持这段时间的学习状态，如果非要给这个保持加一个期限的话，我希望是一辈子！大家加油！等你们的好消息！！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/2018-9-24-第十一周-统计学进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/09/24/2018-9-24-第十一周-统计学进阶/" class="post-title-link" itemprop="url">每周导学-第十一周-统计学进阶</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-24 22:30:09" itemprop="dateCreated datePublished" datetime="2018-09-24T22:30:09+08:00">2018-09-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 12:51:55" itemprop="dateModified" datetime="2019-04-03T12:51:55+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DAND-VIP/" itemprop="url" rel="index"><span itemprop="name">DAND-VIP</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/09/24/2018-9-24-第十一周-统计学进阶/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/09/24/2018-9-24-第十一周-统计学进阶/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p> Everything is difficult until you know how to do it.</p>
</blockquote>
<p>Hi，同学们，上周我们学习了统计学基础知识，包括概率基础、描述统计学和推论统计学的基础知识，本周我们将会进一步学习推论统计学——<strong>置信区间&amp;假设检验</strong>以及它们的应用之一<strong>A/B-test</strong>，在这之后，我们还会讲解一部分机器学习入门——<strong>线性回归&amp;逻辑回归</strong>，与上周相比，这周我们会接触较深的理论知识，更多的代码，你可能会觉得学起来有些吃力，但请一定保持信心，你可以多次暂停观看课程中的讲解视频，跟着一起多动手，或者你也可以按照下面我给出的<strong>额外资料</strong>去查漏补缺，相信你们一定可以的！</p>
<p><strong>项目四(P4)阶段</strong>总共包含<strong>三周</strong>，在这三周内，我们要对<strong>统计学</strong>进行学习，掌握基础的<strong>描述统计学理论、基本的概率知识、二项分布和贝叶斯公式</strong>，并学会<strong>使用 Python 来实践</strong>；学习<strong>正态分布、抽样分布、置信区间以及假设检验的概念和计算方式</strong>；学习<strong>线性回归以及逻辑回归</strong>，在真实场景中应用，比如<strong>分析 A/B 测试</strong>结果，搭建简单的监督机器学习模型。可谓是时间紧任务重，但是也别怕，统计学的基础知识还是非常简单的，跟着课程内容一步步来，自己多做笔记多查资料，一定没问题的！</p>
<p>那么我们的课程安排：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>学习重点</th>
<th>对应课程</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1周</td>
<td>统计学基础</td>
<td>描述统计学 - 抽样分布与中心极限定理</td>
</tr>
<tr>
<td><strong>第2周</strong></td>
<td><strong>统计学进阶</strong></td>
<td><strong>置信区间 - 逻辑回归</strong></td>
</tr>
<tr>
<td>第3周</td>
<td>完成项目</td>
<td>项目：分析A/B测试结果</td>
</tr>
</tbody>
</table>
<p>本阶段可能是个挑战，请一定要<strong>保持自信</strong>，请一定要坚持<strong>学习和总结</strong>，如果遇到任何<strong>课程问题</strong>请参照如下顺序进行解决：</p>
<ul>
<li>先自行查找问题答案（注意提取关键词），参考：谷歌/必应搜索、<a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a>、<a href="https://stackoverflow.com/" target="_blank" rel="noopener">stack<strong>overflow</strong></a></li>
<li>额外参考资料：<ul>
<li><a href="https://www.khanacademy.org/math/statistics-probability" target="_blank" rel="noopener">可汗学院概率论与统计课程</a></li>
<li><a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/%E6%9C%BA%E4%BC%9A%E7%9A%84%E6%95%B0%E5%AD%A6-%E9%99%88%E5%B8%8C%E5%AD%BA.pdf" target="_blank" rel="noopener">机会的数学-陈希孺</a></li>
<li><a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87%E5%8F%8A%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F%E5%8F%8A%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F.pdf" target="_blank" rel="noopener">条件概率及全概率公式及贝叶斯公式</a></li>
<li><a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/statistics%20for%20data%20science.pdf" target="_blank" rel="noopener">statistics for data science</a></li>
</ul>
</li>
<li>若问题未解决，请将<strong>问题</strong>及其<strong>所在课程章节</strong>发送至微信群，并@助教即可</li>
</ul>
<p>饭要一口一口吃，路要一步一步走，大家不要被任务吓到，跟着导学一步一步来，肯定没问题哒！那我们开始吧！</p>
<blockquote>
<p><strong>注：</strong>本着<strong>按需知情</strong>原则，所涉及的知识点都是在数据分析过程中必须的、常用的，而不是最全面的，想要更丰富，那就需要你们课下再进一步的学习和探索！</p>
</blockquote>
<h1 id="本周目标"><a href="#本周目标" class="headerlink" title="本周目标"></a>本周目标</h1><p>学习课程中的<strong>置信区间 - 逻辑回归</strong>课程，掌握统计学进阶知识。</p>
<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><table>
<thead>
<tr>
<th>时间</th>
<th>学习资源</th>
<th>学习内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>周二</td>
<td>微信群 - 每周导学</td>
<td>预览每周导学</td>
</tr>
<tr>
<td>周三、周四</td>
<td>Udacity - Classroom</td>
<td>置信区间 - 逻辑回归</td>
</tr>
<tr>
<td>周五</td>
<td>微信/Classin - 1V1</td>
<td>课程难点</td>
</tr>
<tr>
<td>周六</td>
<td>Classin - 优达日</td>
<td>本周学习总结、答疑</td>
</tr>
<tr>
<td>周日</td>
<td>笔记本</td>
<td>总结沉淀</td>
</tr>
<tr>
<td>周一</td>
<td>自主学习</td>
<td>查漏补缺</td>
</tr>
</tbody>
</table>
<h1 id="知识清单"><a href="#知识清单" class="headerlink" title="知识清单"></a>知识清单</h1><h2 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h2><p>学习之前可以先回顾一下正态分布、抽样分布和中心极限定理的相关知识。</p>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>还记得上周用到的优达学生喝咖啡的数据吗？我们同样以此为例来探讨下置信区间是什么。</p>
<p>假设，优达的学生有数十万个（<strong>总体</strong>），而我们能获得的学生数据只有几百个（<strong>样本</strong>），我们通过做样本均值进行抽样分布，得到了一个近似正态分布的图形，但这也仅仅是样本的均值分布，也就是<strong>样本统计量</strong>。我们利用样本统计量的分布去构造总体均值（<strong>总体参数</strong>）的估计区间，就叫做<strong>置信区间</strong>。</p>
<h3 id="有什么"><a href="#有什么" class="headerlink" title="有什么"></a>有什么</h3><ul>
<li><p>置信区间的两种应用</p>
<ul>
<li><p>刚才的举例中我们用得是“均值”，这算是利用抽样分布建立<strong>单个参数的置信区间</strong>，可以应用在单变量估计等方面；</p>
</li>
<li><p>你还可以计算两种分类之间均值的差，这就是<strong>两个参数的置信区间</strong>，可以用在两变量的对比(A/B-Test)上，比如说医学上不同药物的治疗效果，不同广告的吸金率，不同网页的点击率等等。</p>
</li>
</ul>
</li>
<li><p>置信区间的显著性</p>
<ul>
<li><p><strong>统计显著性</strong>：即我们通过理论分析得到的结果。在统计学上用α表示，叫做<em>显著性水平</em>，它表达的是区间估计的不可靠概率。比如说，我们获取了95%的置信区间，那么显著性水平α = 1 - P = 5%。</p>
<blockquote>
<p>一般的，显著性水平都要求达到5%即可，这在之后的假设检验中会学习到。</p>
</blockquote>
</li>
<li><p><strong>实际显著性</strong>：即我们除了理论分析得到的结果外，还要考虑实际情况，比如说你能有多少资金用于投资，或者你的网站承载力能达到多少等。</p>
</li>
</ul>
</li>
<li><p>与传统置信区间方法的对比</p>
<p>传统的置信区间/假设检验方法有很多，比如说t-检验、双边t-检验等等，但是我们所掌握的<strong>自助取样法</strong>可以代替他们全部，当然有一个前提条件，那就是你的样本容量一定要足够大，如果你的样本容量实在是少，那就只能选择传统方法去处理了。</p>
<blockquote>
<p>获取传统方法python代码的方法，请自行去Stackoverflow搜索。</p>
</blockquote>
</li>
<li><p>准确性&amp;可靠性</p>
<p>这里课程中翻译的有点儿晦涩，这里着重讲一下，我们以候选人A为例（在95%可靠性下具有34%±3%的支持率），大概分布可以如下所示：<del>字丑就将就着点看吧。。。</del></p>
<p><a href="https://imgchr.com/i/iVvVW8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/16/iVvVW8.md.png" alt="iVvVW8.md.png"></a></p>
<ul>
<li>在上图中我们能发现，置信区间的置信概率（可靠性）越高，置信区间的宽度也就越宽，误差范围（准确性）也就会越大；那么当我们缩小误差范围时，置信区间的宽度和可靠性也就随之降低。</li>
<li>结论：置信区间的准确性和可靠性是一对相互矛盾的标准，所以在实际工作中，只能提出其中一个条件，然后推求另一条件的变动情况，如果所推求的另一条件不能满足要求，就应该考虑增加样本容量，重新进行抽样，直至符合要求为止。</li>
</ul>
</li>
</ul>
<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>课程中已经给出了很好的示例、问题及解答，在这里只是拎出一些面生的代码进行讲解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置随机种子，能保证结果之后可以复现</span></span><br><span class="line">np.random.seed(<span class="number">7</span>)</span><br><span class="line"><span class="comment">#按百分比取值</span></span><br><span class="line">np.percentile(array,q)<span class="comment">#q介于0到100，取的是array中的q%位置的数。（从小至大排序）</span></span><br><span class="line"><span class="comment">#拓展——按分位数取值，其实效果和上面按百分比取值一样，只是q值的范围变了</span></span><br><span class="line">np.quantile(array,q)<span class="comment">#q介于0到1，取的是array中的q位置的数。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：置信区间和假设检验只关注的是总体参数，而不能对某一个体下结论。</p>
</blockquote>
<h2 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>基本概念</li>
</ul>
<p>刚才我们讲解了什么是置信区间——为了得到总体指标，使用<strong>样本统计量</strong>去估计<strong>总体参数</strong>——这是一个从样本出发去研究总体的过程。</p>
<p>我们现在换一个角度，在实际分析问题中，能否去假定<strong>总体参数</strong>，然后根据样本数据，去检验这种假定是否正确，从而实现对总体指标的分析？其实这种从总体出发，用样本尺度去检验实现对总体参数分析的过程，就叫做<strong>假设检验</strong>。</p>
<blockquote>
<p><strong>置信区间与假设检验的关系</strong>：从上面的表述可以看出，假设检验和置信区间在本质上是一致的。如果使用样本数据对总体参数进行估计，在一定的置信区间下，总体参数就应该落在这个区间，如果假设的总体参数不在该区间中，则就有理由拒绝该假设，这其实就是从置信区间的角度去完成了假设检验的工作内容。</p>
</blockquote>
<ul>
<li><p>名词解释</p>
<ul>
<li><strong>零假设H0</strong>：一般的，零假设就是你不想要的结果，总包含等号。我们的目的就是要证明零假设是不成立的，是可拒绝的。比如说，你更新了网页设计，不想看到的是更不更新对你网站的流量没什么影响，那么零假设就可以这样设置。</li>
<li><strong>备择假设H1</strong>：一般的，这就是你想要的结果。注意，备择假设应该是零假设的对立。</li>
<li>一类错误：原假设H0为真，却被拒绝。也叫拒真概率，一类错误是更为严重的错误。</li>
<li>二类错误：原假设H0为假，却被接受。也叫受伪概率。</li>
</ul>
<blockquote>
<p>在实际工作中，我们不可能要求一个检验方法永远不出错，但可以要求尽可能地减少犯错误的概率。但在样本容量给定的条件下，两种错误发生的概率必是此消彼长，因此，我们通常是控制第一类错误的概率，使它不超过某一给定的值（一般的取0.05），这样加以控制第一类错误，以此来制约犯第二类错误的概率。</p>
</blockquote>
<ul>
<li><p><strong>p值</strong>：当零假设为真时，我们以<strong>零假设的参数</strong>建立正态分布（根据中心极限定理，当样本数量和抽样次数足够大时，抽样分布趋于正态分布），在该正态分布中观察到<strong>样本统计量</strong>甚至是更极端值（也就是偏向备则假设）的概率。</p>
<p>若这个概率很大，比如说p = 1，那么就表示样本统计量在按照零假设模拟的正态分布内，我们就不能拒绝零假设；</p>
<p>若这个概率很小，比如说 p &lt; 0.05，那么在我们模拟的正态分布中观察到样本统计量的概率就是一个<strong>小概率事件</strong>，我们就可以拒绝零假设；</p>
<p>若p值等于0.05，可增加样本容量，重新进行抽样检验。</p>
</li>
</ul>
</li>
</ul>
<h3 id="有什么-1"><a href="#有什么-1" class="headerlink" title="有什么"></a>有什么</h3><ul>
<li><p>假设检验的基本思想</p>
<ul>
<li><strong>逻辑上的反证法</strong>：我们先假设原命题（零假设H0）成立，然后推出明显矛盾的结果，证明原命题不成立，则我们的所证命题（备择假设H1）成立。</li>
<li><strong>小概率事件</strong>：概率很小的随机事件再一次随机实验中可以认为几乎是不会发生的，这就是小概率事件，我们证明零假设H0不成立，就是利用的小概率事件。</li>
</ul>
<p>假设检验的基本思想可以归纳为：我们把不想要的结果（即零假设H0）假设成立，然后利用样本计算出该假设成立时的概率（即支持该假设的概率，也就是<strong>p-value</strong>），如果这个概率小于显著性水平α（一般的为0.05），那么就可以说明零假设是小概率事件，可以拒绝，就证明了我们想要的结果（即备择假设H1）成立，可以表述为：<strong>在显著性水平α下拒绝原假设</strong>。</p>
<blockquote>
<p>试着理解一下上面这段话，如果理解不了，可以看看<strong>怎么用</strong>，会有详细的分步讲解。</p>
</blockquote>
</li>
<li><p>进行多次假设检验的校正</p>
<ul>
<li>Bonferroni Correction：是一种降低多重比较时第一类错误的矫正方法，举例说明该用法：如果你想在 20 个假设检验中把 I 类错误率维持在 1%，<strong>邦弗朗尼</strong> 校正率应为 0.01/20 = 0.0005。你应该使用这个新比率作为显著性水平α，对比每 20 个检验的 p 值，再做出决定。</li>
</ul>
</li>
</ul>
<h3 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用"></a>怎么用</h3><ul>
<li>建立假设： 一般的都是均值或和与某数值之间的关系。示例如下：</li>
</ul>
<p>$$<br>H_0:\mu  \leqslant 7<br>$$</p>
<p>$$<br>H_1:\mu  &gt;  7<br>$$</p>
<ul>
<li>进行多次重复取样（自助法）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从原数据集中取样，样本容量要大于30</span></span><br><span class="line">sample_df = df.sample(<span class="number">100</span>)</span><br><span class="line"><span class="comment">#新建列表</span></span><br><span class="line">means = []</span><br><span class="line"><span class="comment">#循环取样，并计算均值，存贮在列表中</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    bootsample = sample_df.sample(<span class="number">100</span>,replace = <span class="literal">True</span>)<span class="comment">#设置重复取样</span></span><br><span class="line">    means.append(bootsample.height.mean())<span class="comment">#计算数据集中height变量的均值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>构建零假设的正态分布（因为根据中心极限定理可知，当样本容量足够大，取样次数足够多时，均值的抽样分布近似于正态分布）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算抽样分布的标准差</span></span><br><span class="line">null_std = np.std(means)</span><br><span class="line"><span class="comment">#构建正态分布</span></span><br><span class="line">null_vals = np.random.normal(<span class="number">7</span>,null_std,<span class="number">10000</span>)<span class="comment">#三个参数依次为正态分布的均值、标准差和取值数量，其中均值即为零假设设置的值。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>计算p值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算原始样本的均值</span></span><br><span class="line">sample_mean = sample_df.height.mean()</span><br><span class="line"><span class="comment">#计算支撑原假设的概率，即p值。计算由原假设构建的正态分布（均值为7）大于样本统计量的概率。</span></span><br><span class="line">p_value = (null_vals &gt; sample_mean).mean()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若零假设为：u ≥ 7，则p_value = (null_vals &lt; sample_mean ).mean();</p>
<p>若零假设为：u = 7，则p_value = (null_vals &lt; sample_mean).mean() + (null_vals &gt; null_mean  + (null_mean - sample_mean) ).mean()</p>
</blockquote>
<h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>线性回归是属于机器学习中监督学习范畴的一种简单预测算法。我们通过查看两个<strong>定量变量</strong>之间是否存在线性关系，来进行预测。一般使用<strong>散点图</strong>对变量之间的关系进行可视化。</p>
<ul>
<li><strong>反应变量</strong>就是你想进行预测的变量，其实也就是因变量(y)；</li>
<li><p><strong>解释变量</strong>就是你用于预测的变量，其实也就是自变量(x)。</p>
</li>
<li><p><strong>相关系数</strong>：最常用的就是<strong>皮尔逊相关系数</strong>，用r表示，取值范围为[-1,1]，正值表示正相关，负值表示负相关，绝对值越大，相关性就越强。在描述相关性强弱时，可以参考如下取值范围：</p>
<p><img src="https://s1.ax1x.com/2018/09/19/imFK0K.png" alt="imFK0K.png"></p>
<blockquote>
<p> 关于更多更详细的相关系数的知识，请戳<a href="http://blog.sina.com.cn/s/blog_69e75efd0102wmd2.html" target="_blank" rel="noopener">统计学之三大相关性系数</a>，博主写得深入浅出，而且有很多浅显易懂的例子，感兴趣的话可以看看。</p>
</blockquote>
</li>
</ul>
<h3 id="方程"><a href="#方程" class="headerlink" title="方程"></a>方程</h3><ul>
<li>方程模型</li>
</ul>
<p>线性回归的方程模型就是一元一次方程，如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/09/29/ila641.png" alt="ila641.png"></p>
<p>b0表示<strong>截距</strong>，也就是回归线与y轴交点的y坐标；</p>
<p>b1表示<strong>斜率</strong>，也就是回归线的倾斜程度；</p>
<p>y^ 表示回归线反应变量的预测值，并不是确切的数据集中的y值。</p>
<ul>
<li>拟合回归线</li>
</ul>
<p>拟合回归线时我们采用的主要算法叫做 <strong>最小二乘法</strong>，即通过回归线得到的预测反应变量值与实际反应变量之差最小时的那条就是最佳拟合回归线，其原理公式可以表示为：</p>
<p><img src="https://s1.ax1x.com/2018/09/29/ilag9x.png" alt="ilag9x.png"></p>
<h3 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h3><p>在python中我们需要调用<code>statsmodels</code>包来拟合回归线：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载statsmodels包</span></span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="comment">#注意一定不要忘了截距</span></span><br><span class="line">df[<span class="string">'intercept'</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 构建变量模型及其拟合</span></span><br><span class="line"><span class="comment"># y为因变量，X表示单个或多个自变量（其中要包含截距），例如 df[["intercept", "area"]] 包括了截距和面积两个变量</span></span><br><span class="line">lm = sm.OLS(y, X) 		</span><br><span class="line">result = lm.fit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最终的拟合模型报告</span></span><br><span class="line">print(result.summary())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在建立模型时，一般情况下都是需要手动添加截距（一般为常数 1）， 想了解更多，可以查阅<a href="http://statistiksoftware.blogspot.com/2013/01/why-we-need-intercept.html" target="_blank" rel="noopener">Statcon: Why we need the intercept</a>或者<a href="https://stats.stackexchange.com/questions/7948/when-is-it-ok-to-remove-the-intercept-in-a-linear-regression-model" target="_blank" rel="noopener">When is it ok to remove the intercept in a linear regression model? - Cross Validated</a></p>
</blockquote>
<h3 id="参数和结果解释"><a href="#参数和结果解释" class="headerlink" title="参数和结果解释"></a>参数和结果解释</h3><ul>
<li><code>coef</code>：对应变量的参数值</li>
<li><code>std err</code>：标准误差</li>
<li><code>t</code>：统计检验值</li>
<li><code>P&gt;|t|</code> ：这个是对应的 <code>p</code> 值，它的零假设为该变量的参数值等于0，可以指示该变量是否有利于预测反应变量，也能用于比较多个变量中哪个更重要。</li>
<li><code>R-squared</code> ：即决定系数，它是相关系数的平方。取值范围在[0,1]，值越大，拟合效果就越好，这个值的统计意义可以简单解释为此次拟合中的解释变量能有多少百分比的可能去解释反应变量。</li>
</ul>
<h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>多元线性回归就是由多个自变量去预测因变量的方法，其模型方程与简单线性回归基本一致，只不过是将单自变量变为了多个自变量的矩阵，如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/09/29/ilaRgK.png" alt="ilaRgK.png"></p>
<p>其中<strong>X</strong>就是多个自变量的矩阵。</p>
<h3 id="编程实现-1"><a href="#编程实现-1" class="headerlink" title="编程实现"></a>编程实现</h3><p>在Python中的编程实现步骤也如简单线性回归类似，别忘了要定义一个截距</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载statsmodels包</span></span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="comment">#注意一定不要忘了截距</span></span><br><span class="line">df[<span class="string">'intercept'</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 构建变量模型及其拟合</span></span><br><span class="line"><span class="comment"># y为因变量，X表示多个自变量的矩阵（其中要包含截距），例如 df[["intercept", "area","bedroom", "bathroom"]] 包括了截距和面积、卧室数量、洗手间数量四个变量</span></span><br><span class="line">lm = sm.OLS(y, X) 		</span><br><span class="line">result = lm.fit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最终的拟合模型报告</span></span><br><span class="line">print(result.summary())</span><br></pre></td></tr></table></figure>
<h3 id="参数和结果解释-1"><a href="#参数和结果解释-1" class="headerlink" title="参数和结果解释"></a>参数和结果解释</h3><p>这里和简单线性回归是一致的，只不过在解释单个自变量与因变量之间的关系时，需要加上一句“<strong>在其它变量不变的情况下</strong>……”</p>
<h3 id="处理分类变量"><a href="#处理分类变量" class="headerlink" title="处理分类变量"></a>处理分类变量</h3><ul>
<li>思路</li>
</ul>
<p>处理分类变量的一个思路就是将其转化为<strong>虚拟变量</strong>，也就是将各个分类变量单独成列，然后把观察行对应的分类变量量化为0（可理解为“否”）和1（可理解为“是”）作为该列的元素，再进行拟合处理。</p>
<p>在拟合处理时，我们添加的虚拟变量的数量应该为原数据集中的虚拟变量总数减一。</p>
<blockquote>
<p>因为要计算最佳拟合系数时，需要用到变量矩阵的转秩，而判断矩阵是否可逆的充分必要条件就是这个矩阵是满秩的，又因为我们的虚拟变量矩阵中每一个变量都可以由其他变量推导而来，所以必须要舍弃一列才能确保变量矩阵为满秩。【感兴趣可以去可汗学院补一补线性代数知识】</p>
</blockquote>
<ul>
<li>方法</li>
</ul>
<p>使用pandas中的get_dummies函数来进行虚拟变量的转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对neighborhood列进行量化，并将结果存储在df数据集的A/B/C三个新列中</span></span><br><span class="line">df[[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]] = pd.get_dummies(df[<span class="string">'neighborhood'</span>])</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：get_dummies函数输出结果的默认排序为字典顺序（即a-z），所以在进行新列储存时，一定要注意原始变量中的分类与虚拟变量列一一对应。</p>
<ul>
<li>结果解释</li>
</ul>
<p>还是以ABC三个分类变量来假设，我们以C作为<strong>基准变量</strong>（也就是删除的那列），那么在显示的结果中：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">coef</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Intercept</td>
<td style="text-align:center">i</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">b</td>
</tr>
</tbody>
</table>
<p>1.Intercept的coef表示：如果分类为C的话，因变量即为i；</p>
<p>2.A的coef表示：如果分类为A的话，因变量为i+a;</p>
<p>3.B的coef表示：如果分类为B的话，因变量为i+b。</p>
<h3 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h3><p>这部分课程中给了很多额外资料的链接，理论性很重，不太好啃，建议等通关后复盘的时候试着看一看。</p>
<h3 id="多重共线性现象和分析"><a href="#多重共线性现象和分析" class="headerlink" title="多重共线性现象和分析"></a>多重共线性现象和分析</h3><p>如果我们的自变量彼此相关，就会出现多重共线性。多重共线性的一个主要问题在于：它会导致简单线性回归系数偏离我们想要的方向。要判断是否有多重共线性，最常见的办法是借助散点图或 <strong>方差膨胀因子 (即 VIF)</strong>。</p>
<ul>
<li>散点图</li>
</ul>
<p>散点图比较好理解，使用之前提到过的seaborn中的pairplot能很直观的看出各个变量之间的相关性。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.pairplot(df[[<span class="string">"col_1"</span>, <span class="string">"col_2"</span>, <span class="string">"col_3"</span>]])</span><br></pre></td></tr></table></figure>
<ul>
<li>方差膨胀因子</li>
</ul>
<p><a href="https://etav.github.io/python/vif_factor_python.html" target="_blank" rel="noopener">方差膨胀因子(Variance Inflation Factor，VIF)</a>是指解释变量之间存在多重共线性时的方差与不存在多重共线性时的方差之比。具体的计算方法如下（计算不做要求，但要理解） </p>
<blockquote>
<p>假若有X1 、X2 、X3三个自变量，X1的vif计算：<br>1.x1对常数项（截距）、x2、x3做多元线性回归，求出R^2<br>2.则变量X1的VIF＝1/(1-R^2)<br>3.同理计算出变量X2和X3的VIF。</p>
</blockquote>
<p>它是指示多元线性回归中多重共线性严重与否的指标，VIF越大，多重共线性就越严重。</p>
<p>经验判断方法表明：</p>
<p>当0&lt;VIF&lt;10，不存在多重共线性；</p>
<p>当10≤VIF&lt;100，存在较强的多重共线性；</p>
<p>当VIF≥100，存在严重多重共线性。</p>
<p>所以我们在处理的时候，就要去除VIF超过10的最不感兴趣的变量。</p>
<p>在python中的编程实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算 VIF 需要使用 statsmodel 包</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.stats.outliers_influence <span class="keyword">import</span> variance_inflation_factor</span><br><span class="line"><span class="keyword">from</span> patsy <span class="keyword">import</span> dmatrices	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出作线性回归的变量（截距不要加）</span></span><br><span class="line">y, X = dmatrices(<span class="string">'col_y ~ col_1 + col_2 + col_3'</span>, df, return_type=<span class="string">'dataframe'</span>)</span><br><span class="line">vif = pd.DataFrame()</span><br><span class="line"><span class="comment"># 使用 variance_inflation_factor 来计算 VIF，并储存在vif DataFrame中</span></span><br><span class="line">vif[<span class="string">"VIF Factor"</span>] = [variance_inflation_factor(X.values, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">1</span>])] </span><br><span class="line">vif[<span class="string">"features"</span>] = X.columns</span><br></pre></td></tr></table></figure>
<h2 id="【选修】高阶项"><a href="#【选修】高阶项" class="headerlink" title="【选修】高阶项"></a>【选修】高阶项</h2><p>高阶项就是在回归模型中添加诸如x^2,x^3,x1·x2等变量，获取的方式可以直接使用df[‘col_1’]进行高阶计算即可。</p>
<p>关键是在于观察变量之间的散点图，来确定是否需要添加高阶项。</p>
<ul>
<li>二阶、三阶的函数曲线很有辨识度，观察他们拐几个弯就可以；</li>
<li>交叉项的话，就看两自变量各自与因变量之间的回归线，如果回归线几乎平行，那就不必添加交叉项；</li>
</ul>
<p><strong>注意</strong>：如果确定要添加某变量的高阶项，一定要确保该变量也要添加进去。</p>
<p><strong>之后的24-33节也是选修，而且给了Udacity一套免费的机器学习入门课程，建议通关后再来复盘。</strong></p>
<h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>逻辑回归就是对分类变量进行预测的方法，尤其是对二分类问题（非1即0），比如说是否使用优惠券，是否存在贷款逾期问题等等。</p>
<h3 id="方程-1"><a href="#方程-1" class="headerlink" title="方程"></a>方程</h3><p>逻辑回归的方程模型就是<strong>sigmoid</strong>函数：</p>
<p><img src="https://s1.ax1x.com/2018/09/25/iKlzUe.png" alt="iKlzUe.png"></p>
<p>结合二分类问题的概率，做对数变换可得：</p>
<p><img src="https://s1.ax1x.com/2018/11/17/izcBWD.png" alt="izcBWD.png"></p>
<p>如上p/(1-p)即为事件的<strong>机会比</strong>，在该问题中，能预测范围在0到1之间。</p>
<h3 id="编程实现-2"><a href="#编程实现-2" class="headerlink" title="编程实现"></a>编程实现</h3><p>编程实现与线性回归类似，只不过将最小二乘法（OLS）替换成了逻辑回归（Logit）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载statsmodels包</span></span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="comment">#注意一定不要忘了截距</span></span><br><span class="line">df[<span class="string">'intercept'</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 构建变量模型及其拟合</span></span><br><span class="line"><span class="comment"># y为二分类变量，X表示多个自变量的矩阵（其中要包含截距），例如 df[["intercept","duration"]] 包括了截距和持续时间</span></span><br><span class="line">lm = sm.Logit(y, X) 		</span><br><span class="line">result = lm.fit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最终的拟合模型报告</span></span><br><span class="line">print(result.summary())</span><br></pre></td></tr></table></figure>
<h3 id="参数和结果解释-2"><a href="#参数和结果解释-2" class="headerlink" title="参数和结果解释"></a>参数和结果解释</h3><ul>
<li><code>coef</code>：对应变量的系数</li>
<li><code>std err</code>：标准误差</li>
<li><code>t</code>：统计检验值</li>
<li><code>P&gt;|t|</code> ：这个是对应的 <code>p</code> 值，可以指示该变量是否有利于预测反应变量，也能用于比较多个变量中哪个更重要。</li>
</ul>
<p>在这里我们并不关注截距，而重点关注各个解释变量。</p>
<p>在进行结果解释时我们常说：</p>
<p><strong>在保持其他变量不变的情况下</strong>，</p>
<ul>
<li>（对于数值变量）该变量每增加一个单位，那么作为y的分类变量则增大e^coef倍；</li>
<li>（对于分类变量）该变量为它的对立时，作为y的分类变量发生的几率为该变量基础的e^coef倍。</li>
</ul>
<h3 id="【选修】模型评估"><a href="#【选修】模型评估" class="headerlink" title="【选修】模型评估"></a>【选修】模型评估</h3><p>之后的课程已经是机器学习入门阶段的范畴，可以等通关后，再去研究。（建议先开始免费的机器学习课程，再结合本章内容复盘看，更有助于你理解）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本周导学的内容较难，理解起来也比较困难，对于置信区间和假设检验两节，大家可以再额外补充一些统计学方面的相关知识，更有助于你理解；对于回归知识，建议多看几遍教学视频再结合例题，在实践中不断尝试去理解，大家加油！下周就要开始项目四了，阶段性的胜利就在前方！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/13/2018-9-13-第十周-统计学基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/09/13/2018-9-13-第十周-统计学基础/" class="post-title-link" itemprop="url">每周导学-第十周-统计学基础</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-13 12:30:09" itemprop="dateCreated datePublished" datetime="2018-09-13T12:30:09+08:00">2018-09-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 12:51:55" itemprop="dateModified" datetime="2019-04-03T12:51:55+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DAND-VIP/" itemprop="url" rel="index"><span itemprop="name">DAND-VIP</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/09/13/2018-9-13-第十周-统计学基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/09/13/2018-9-13-第十周-统计学基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>If you tell yourself you can’t, you won’t.</p>
</blockquote>
<p>Hi，同学们，上一阶段我们学习了数据分析的基本流程、Pandas在数据分析各个过程中的应用以及Matplotlib&amp;Pandas的可视化基础，截至目前，你们已经算是掌握了基础的数据分析技能啦！撒花！但是在统计学理论和预测方面仍有欠缺，那么P4阶段就是解决这个欠缺哒！</p>
<p>本周开始，我们就进入到了<strong>项目四(P4)阶段</strong>，本阶段总共包含<strong>三周</strong>，在这三周内，我们要对<strong>统计学</strong>进行学习，掌握基础的<strong>描述统计学理论、基本的概率知识、二项分布和贝叶斯公式</strong>，并学会<strong>使用 Python 来实践</strong>；学习<strong>正态分布、抽样分布、置信区间以及假设检验的概念和计算方式</strong>；学习<strong>线性回归以及逻辑回归</strong>，在真实场景中应用，比如<strong>分析 A/B 测试</strong>结果，搭建简单的监督机器学习模型。可谓是时间紧任务重，但是也别怕，统计学的基础知识还是非常简单的，跟着课程内容一步步来，自己多做笔记多查资料，一定没问题的！</p>
<p>那么我们的课程安排：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>学习重点</th>
<th>对应课程</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>第1周</strong></td>
<td><strong>统计学基础</strong></td>
<td><strong>描述统计学 - 抽样分布与中心极限定理</strong></td>
</tr>
<tr>
<td>第2周</td>
<td>统计学进阶</td>
<td>置信区间 - 逻辑回归</td>
</tr>
<tr>
<td>第3周</td>
<td>完成项目</td>
<td>项目：分析A/B测试结果</td>
</tr>
</tbody>
</table>
<p>本阶段可能是个挑战，请一定要<strong>保持自信</strong>，请一定要坚持<strong>学习和总结</strong>，如果遇到任何<strong>课程问题</strong>请参照如下顺序进行解决：</p>
<ul>
<li>先自行查找问题答案（注意提取关键词），参考：谷歌/必应搜索、<a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a>、<a href="https://stackoverflow.com/" target="_blank" rel="noopener">stack<strong>overflow</strong></a></li>
<li>额外参考资料：<ul>
<li><a href="https://www.khanacademy.org/math/statistics-probability" target="_blank" rel="noopener">可汗学院概率论与统计课程</a></li>
<li><a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/%E6%9C%BA%E4%BC%9A%E7%9A%84%E6%95%B0%E5%AD%A6-%E9%99%88%E5%B8%8C%E5%AD%BA.pdf" target="_blank" rel="noopener">机会的数学-陈希孺</a></li>
<li><a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87%E5%8F%8A%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F%E5%8F%8A%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F.pdf" target="_blank" rel="noopener">条件概率及全概率公式及贝叶斯公式</a></li>
<li><a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/statistics%20for%20data%20science.pdf" target="_blank" rel="noopener">statistics for data science</a></li>
</ul>
</li>
<li>若问题未解决，请将<strong>问题</strong>及其<strong>所在课程章节</strong>发送至微信群，并@助教即可</li>
</ul>
<p>饭要一口一口吃，路要一步一步走，大家不要被任务吓到，跟着导学一步一步来，肯定没问题哒！那我们开始吧！</p>
<blockquote>
<p><strong>注：</strong>本着<strong>按需知情</strong>原则，所涉及的知识点都是在数据分析过程中必须的、常用的，而不是最全面的，想要更丰富，那就需要你们课下再进一步的学习和探索！</p>
</blockquote>
<h1 id="本周目标"><a href="#本周目标" class="headerlink" title="本周目标"></a>本周目标</h1><p>学习课程中的<strong>描述统计学 - 抽样分布与中心极限定理</strong>课程，掌握统计学基础知识。</p>
<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><table>
<thead>
<tr>
<th>时间</th>
<th>学习资源</th>
<th>学习内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>周二</td>
<td>微信群 - 每周导学</td>
<td>预览每周导学</td>
</tr>
<tr>
<td>周三、周四</td>
<td>Udacity - Classroom</td>
<td>描述统计学 - 抽样分布与中心极限定理</td>
</tr>
<tr>
<td>周五</td>
<td>微信/Classin - 1V1</td>
<td>课程难点</td>
</tr>
<tr>
<td>周六</td>
<td>Classin - 优达日</td>
<td>本周学习总结、答疑</td>
</tr>
<tr>
<td>周日</td>
<td>笔记本</td>
<td>总结沉淀</td>
</tr>
<tr>
<td>周一</td>
<td>自主学习</td>
<td>查漏补缺</td>
</tr>
</tbody>
</table>
<h1 id="本周知识清单"><a href="#本周知识清单" class="headerlink" title="本周知识清单"></a>本周知识清单</h1><h2 id="描述统计学基础"><a href="#描述统计学基础" class="headerlink" title="描述统计学基础"></a>描述统计学基础</h2><p>描述统计分析就是通过数字或可视化的方法，对数据集进行整理、分析，并对数据的分布状态、数字特征和随机变量之间的关系进行估计和描述。其简要可以分为集中趋势分析、离散程度分析以及相关分析三大部分。所以，虽然这部分是选修内容，但拜托各位一定要看，这部分理论是数据分析的基础。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型是基础，尤其是之后在进行回归预测时，针对不同的数据类型可以选择不同的算法，所以必须掌握。</p>
<p>数据类型可以分为两大类：数值和分类；进而分为四小类：连续、离散、定序和定类。</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数值:</strong></td>
<td><strong>连续</strong></td>
<td><strong>离散</strong></td>
</tr>
<tr>
<td></td>
<td>身高、年龄、收入</td>
<td>书中的页数、院子里的树、咖啡店里的狗</td>
</tr>
<tr>
<td><strong>分类:</strong></td>
<td><strong>定序</strong></td>
<td><strong>定类</strong></td>
</tr>
<tr>
<td></td>
<td>字母成绩等级、调查评级</td>
<td>性别、婚姻状况、早餐食品</td>
</tr>
</tbody>
</table>
<h3 id="描述统计的量"><a href="#描述统计的量" class="headerlink" title="描述统计的量"></a>描述统计的量</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述方面</th>
<th>描述方式</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数值:</strong></td>
<td><strong>集中趋势</strong></td>
<td>均值</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>中位数</td>
<td>偶数个时取中间两值均数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>众数</td>
<td>存在没有或多个的可能</td>
</tr>
<tr>
<td></td>
<td><strong>离散程度</strong></td>
<td>极差</td>
<td>max - min</td>
</tr>
<tr>
<td></td>
<td></td>
<td>四分位差（IQR）</td>
<td>75%数 - 25%数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>方差</td>
<td>每个观察值与均值之差平方和的平均数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>标准差</td>
<td>方差的平方根</td>
</tr>
<tr>
<td></td>
<td><strong>数据形状</strong></td>
<td>左偏态</td>
<td>均值小于中位数（普遍但不绝对，下同）</td>
</tr>
<tr>
<td></td>
<td>（需做直方图）</td>
<td>右偏态</td>
<td>均值大于中位数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>对称分布（通常是正态分布）</td>
<td>均值等于中位数</td>
</tr>
<tr>
<td></td>
<td><strong>异常值</strong></td>
<td>一般为上下超过1.5倍四分位差</td>
<td>处理方式见下面【异常值的处理】</td>
</tr>
<tr>
<td><strong>分类:</strong></td>
<td>分类计量个数或比例</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><p>偏态分布示意图</p>
<p><img src="https://tse4.mm.bing.net/th?id=OIP.eJMf4CCd_ylkXqyGPD0NbQHaE8&amp;pid=Api" alt></p>
</li>
<li><p>其他概念：</p>
<ul>
<li><p>五数概括描述法：利用<strong>最小值、第一四分位数（25%处）、第二四分位数（中位数）、第三四分位数（75%处）和最大值</strong>五个数对<strong>数值型</strong>变量的<strong>离散程度</strong>进行描述的方法。</p>
</li>
<li><p>当我们的数据遵循<strong>正态</strong>分布时，我们可以使用<code>均值</code>和<code>标准差</code>完全理解我们的数据集。        </p>
<p>但是，如果我们的数据集是<strong>偏态</strong>分布，<code>五数概括法</code>（和关联的集中趋势度量）更适用于概括数据。</p>
</li>
<li><p>除直方图外，你还可以使用<strong>箱线图</strong>进行统计描述，箱线图其实是五数概括法的可视化。</p>
</li>
</ul>
</li>
<li><p>异常值的处理：</p>
<p><strong>1.</strong> 至少注意到它们的存在并确定对概括统计的影响。        </p>
<p><strong>2.</strong> 如果是输入错误 — 删除或改正        </p>
<p><strong>3.</strong> 理解它们为何存在，以及对我们想要回答的关于数据的问题的影响。        </p>
<p><strong>4.</strong> 当有异常值时，报告五数概括法的值通常能比均值和标准差等度量更好地体现异常值的存在。        </p>
<p><strong>5.</strong> 报告时要小心。知道如何提出正确的问题。</p>
</li>
</ul>
<h3 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h3><p>随机变量集用大写字母，如X表示；</p>
<p>而集里面的某个变量用对应的小写字母，如x1，x2等表示。</p>
<h2 id="推论统计学基础"><a href="#推论统计学基础" class="headerlink" title="推论统计学基础"></a>推论统计学基础</h2><p>推论统计就是根据现有收集的部分数据对更大的总体数据进行推论的方法。他的几个关键要素为：</p>
<ol>
<li><strong>总体</strong> —— 我们想要研究的整个群体。        </li>
<li><strong>参数</strong> —— 描述总体的数值摘要        </li>
<li><strong>样本</strong> —— 总体的子集        </li>
<li><strong>统计量</strong> —— 描述样本的数值摘要        </li>
</ol>
<h2 id="辛普森悖论"><a href="#辛普森悖论" class="headerlink" title="辛普森悖论"></a>辛普森悖论</h2><p>本节以录取案例分析为例，展示了辛普森悖论。这个例子不必深究，只是为了提醒大家要<strong>以多种方式去观察数据</strong>，避免出现案例分析中的反例。</p>
<p>辛普森悖论是在某个条件下的两组数据，分别讨论时都会满足某种性质，可是一旦合并考虑，却可能导致相反的结论。那么如何避免辛普森悖论呢？那就要从产生它的源头——混杂因素上考虑，混杂因素就是一个与核心研究无关的变量，它会随着变量的改变而改变，就比如说在课程中的例子中，不同专业的总人数就有很大差异，它会随着专业的改变而改变。所以在之后处理类似问题时就要进行多变量分析，这样才能帮助我们认清事件的本质。</p>
<h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><h3 id="概率与统计的关系"><a href="#概率与统计的关系" class="headerlink" title="概率与统计的关系"></a>概率与统计的关系</h3><p>从课程中给的这幅关系图就能很明显的看出来，概率是由模型（MODEL）去预测数据（DATA），而统计是由数据去建立模型（进而再去做预测，也就是‘’根据数据去预测数据’‘）。</p>
<p><img src="https://s1.ax1x.com/2018/09/12/iAkgoj.png" alt="iAkgoj.png"></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><strong>概率</strong>，是一种几率、可能性，描述是事件发生的可能性度量量。<strong>随机事件</strong>，指一个被赋予机率的事件<br>集合，针对的是事件在样本空间的一个子集。事件A发生的概率，用符号P(A)表示 。</p>
<ul>
<li><p>任何事件的发生概率在 0 和 1 之间，其中包括 0 和 1。（0表示不可能发生，1表示必然发生）</p>
</li>
<li><p>独立事件：事件每次发生的结果与前后的发生结果无关。比如说，第一次掷骰子的结果与第二次的结果</p>
</li>
<li><p>互斥事件：不可能在同一次实验中出现的俩事件。比如说，掷骰子实验中的1和6</p>
</li>
<li><p>对立事件：是一种特殊的互斥事件，即试验中只有俩种可能A和B，那么事情的发生非A即B。可以表示为</p>
<p><img src="https://s1.ax1x.com/2018/09/22/iuFI3Q.png" alt="iuFI3Q.png"></p>
<p>如掷硬币的正面和反面。</p>
</li>
<li><p>加法原理：若两种方法均能完成此事，则此事发生的概率为P(A) + P(B)</p>
</li>
<li>乘法原理：若两个步骤分别不能完成此事，则此事发生的概率为P(A)·P(B)</li>
</ul>
<h3 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h3><p>也叫伯努利分布，是指n个独立的事件A发生的概率分布。设每次试验中事件A发生的概率为p，则进行n次试验，A发生k次的概率为：</p>
<p><img src="https://s1.ax1x.com/2018/09/22/iuFocj.png" alt="iuFocj.png"></p>
<h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>在现实中，我们处理的事情并不像骰子和硬币那样简单，有些时间的结果往往依赖于其他的事情，比如说晨练的概率跟这个人是不是夜猫子有关等等。那么，这就引出了条件概率，即在事件B发生的条件下，事件A发生的概率为：</p>
<p><img src="https://s1.ax1x.com/2018/09/22/iuFTjs.png" alt="iuFTjs.png"></p>
<p>其中，P(AB)表示AB同时发生的概率。</p>
<p>在如下的文氏图中，AB同时发生的概率可以表示为两个圆的交集，那么B已经发生的条件下A发生的概率就是这个交集（橙色部分）占整个B圆的比例。</p>
<p><img src="https://s1.ax1x.com/2018/09/13/iA5UMT.png" alt="iA5UMT.png"></p>
<blockquote>
<p>之前讲过独立事件，那么用公式的方式可以表达为：<code>P(A) = P(A|B)</code>。根据条件概率公式可以推导出，当<code>P(AB) = P(A)P(B)</code>时，则可说明A事件与B事件相互独立。</p>
</blockquote>
<p><strong>全概率公式</strong></p>
<p>也就是A发生的概率为在互斥的多个事件（B1，B2…）已发生的条件下的条件概率之和。公式可以表示为：</p>
<p><img src="https://s1.ax1x.com/2018/09/22/iuFHun.png" alt="iuFHun.png"></p>
<h3 id="贝叶斯法则"><a href="#贝叶斯法则" class="headerlink" title="贝叶斯法则"></a>贝叶斯法则</h3><p>贝叶斯法则是概率推理的黄金法则，是利用先验概率计算后验概率的方法。</p>
<blockquote>
<p>课程中的癌症例子十分贴切，讲解的也十分详细，所以大家<strong>看到前20个小节</strong>，能理解贝叶斯法则就可以了，后面的是在无人驾驶中的应用例子，可以跳过不看。</p>
</blockquote>
<p>在课程示例中：</p>
<p><a href="https://imgchr.com/i/iuFqH0" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/22/iuFqH0.md.png" alt="iuFqH0.md.png"></a></p>
<p>由条件概率能计算出患癌与检查结果为阳性同时发生的概率<code>P(C,Pos)</code>（红色区域占整个矩形的比例）和没患癌与检查结果同时发生的概率<code>P(~C,Pos)</code>（绿色区域占整个矩形的比例）。</p>
<p><img src="https://s1.ax1x.com/2018/09/22/iuFbBq.png" alt="iuFbBq.png"></p>
<p>二者相加，即为检查结果为阳性的概率（全概率公式）P(Pos)。</p>
<p>则，检查结果为阳性的条件下患癌概率为：</p>
<p><img src="https://s1.ax1x.com/2018/09/22/iuFOEV.png" alt="iuFOEV.png"></p>
<p>这样我们就得到了更接近真实的检查结果为阳性的患癌概率。</p>
<p><img src="https://s1.ax1x.com/2018/09/13/iAIrnS.png" alt="iAIrnS.png"></p>
<p>在这个例子中：</p>
<p>癌症发生的概率<code>P(C)</code>为先验概率，即在我们进行检查之前就对患癌概率的一个判断；</p>
<p>阳性结果下为癌症的概率<code>P(C|Pos)</code>为后验概率（阳性下非癌症、阴性癌症、阴性非癌症都是），这些是在检查发生之后，我们对患癌概率这件事的重新评估；</p>
<p><strong>这就是贝叶斯法则的含义。我们先预估一个”先验概率”，然后加入实验结果，由此得到更接近事实的”后验概率”。</strong></p>
<blockquote>
<p>如果感觉理解困难，可以看一下白话版的贝叶斯讲解：<a href="https://www.zhihu.com/question/19725590" target="_blank" rel="noopener">怎样用非数学语言讲解贝叶斯定理（Bayes’s theorem）</a></p>
</blockquote>
<h2 id="Python概率练习"><a href="#Python概率练习" class="headerlink" title="Python概率练习"></a>Python概率练习</h2><p>前面我们学习了概率的基本知识，有了理论基础，本节就是利用Python落地的教学。应用的第三方包为NumPy和Pandas。</p>
<h3 id="均匀随机取整"><a href="#均匀随机取整" class="headerlink" title="均匀随机取整"></a>均匀随机取整</h3><p>使用的函数为<code>numpy.random.randint(low, high=None, size=None, dtype=&#39;l&#39;)</code>：</p>
<ul>
<li>low：当没有high参数输入时，作为取值范围的最大值+1；当有high参数输入时，则作为取值范围的最小值；</li>
<li>high：取值范围的最大值+1，默认为无输入；</li>
<li>size：输入数字则表示取值的数量，输入元组则表示取值矩阵的行和列；</li>
<li>dtype：数据类型，默认为np.int；</li>
<li>函数的输出为int或者是由int数据类型组成的ndarray。</li>
</ul>
<p>函数的具体用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 未定义high参数，取值范围是是0到1（即low - 1）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.randint(<span class="number">2</span>, size=<span class="number">10</span>)</span><br><span class="line">array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># 定义了high参数，取值范围是2（即low）到4（即high - 1）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.randint(<span class="number">2</span>,<span class="number">5</span>,size = <span class="number">10</span>)</span><br><span class="line">array([<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># 定义一个2x4的矩阵，取值范围是0到4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.randint(<span class="number">5</span>, size=(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="不均匀随机取数"><a href="#不均匀随机取数" class="headerlink" title="不均匀随机取数"></a>不均匀随机取数</h3><p>使用的函数为<strong>numpy.random.choice</strong>(<em>a</em>, <em>size=None</em>, <em>replace=True</em>, <em>p=None</em>):</p>
<ul>
<li>a：输入列表时，取数就从该列表中取；若输入为数字时，取值范围为0到该数字 - 1；</li>
<li>size：输入数字则表示取值的数量，输入元组则表示取值矩阵的行和列；</li>
<li>replace：布尔值，默认为True，若设置为False表示取数不会重复；（以从袋子中取球为例，True是取完放回再取，而False则是取了不放回，继续取）</li>
<li>p：表示概率，与a的输入值一一对应。</li>
<li>函数的输出为int或者是由int数据类型组成的ndarray。</li>
</ul>
<p>函数的具体用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入数字时取数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.choice(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">array([<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment">#设置replace参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.choice(<span class="number">5</span>, <span class="number">3</span>, replace=<span class="literal">False</span>)</span><br><span class="line">array([<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment">#设置概率</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.choice(<span class="number">5</span>, <span class="number">3</span>, replace=<span class="literal">False</span>, p=[<span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0.3</span>, <span class="number">0.6</span>, <span class="number">0</span>])</span><br><span class="line">array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="二项分布-1"><a href="#二项分布-1" class="headerlink" title="二项分布"></a>二项分布</h3><p>使用的函数为<strong>numpy.random.binomial</strong>(<em>n</em>, <em>p</em>, <em>size=None</em>)，参数也很好解释。</p>
<p>参数中的n即为每次试验中取值的次数，p则为试验中的某一种事件成功的概率，size则是试验的次数。</p>
<h3 id="条件概率与贝叶斯规则测试"><a href="#条件概率与贝叶斯规则测试" class="headerlink" title="条件概率与贝叶斯规则测试"></a>条件概率与贝叶斯规则测试</h3><p>这里主要是一些Pandas函数的应用，经过上一阶段的学习应该已经很熟练了。</p>
<p>主要涉及的函数是分组和统计计数类的函数，比如说groupby，query，count等，如果忘记的话，自己查官方文档或者之前的笔记，这里不再赘述。</p>
<h2 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h2><p>课程中以抛硬币模型引入了二项分布进而讲解了正态分布模型，那么到底什么是正态分布或者满足什么条件就可以算是正态分布了呢？</p>
<blockquote>
<p>在相同条件下，我们随机地对某一测试对象（抛硬币20次，其中正面的次数）进行多次测试（抛很多次20次）时，测得的数值在一定范围内波动（从0到20），其中接近平均值的数据（10左右）占多数，远离平均值的占少数。具有这种分布规律的随机变量的分布就称作正态分布。</p>
</blockquote>
<p>大概长这样儿：</p>
<p><img src="https://s1.ax1x.com/2018/09/14/iEkWCR.png" alt="iEkWCR.png"></p>
<p>它的概率密度函数可以表示为：</p>
<p><img src="https://s1.ax1x.com/2018/09/22/iuFXNT.png" alt="iuFXNT.png"></p>
<p>这里为什么要引入正态分布呢？</p>
<ul>
<li>假设检验是基于正态分布的</li>
<li>许多社会和经济现象对应的随机变量分布，都可以用正态分布来描述</li>
</ul>
<h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><p>在此之前，先回顾下推论统计的几个概念：</p>
<ol>
<li><strong>总体</strong> —— 我们想要研究的整个群体。        </li>
<li><strong>参数</strong> —— 描述总体的数值摘要        </li>
<li><strong>样本</strong> —— 总体的子集        </li>
<li><strong>统计量</strong> —— 描述样本的数值摘要        </li>
</ol>
<p>课程中举得例子是统计优达学生中喝咖啡的人所占比例，我们看下图：</p>
<p><img src="https://s1.ax1x.com/2018/09/14/iEr4AK.png" alt="iEr4AK.png"></p>
<p>图中所有的杯子（学生）就叫做<strong>总体</strong>；此外可以看到有四个深浅不一的蓝色底框，每个底框链接了5个学生，这5个学生就是<strong>样本</strong>，每组样本我们还计算了喝咖啡的比例，这就是<strong>统计量</strong>。</p>
<blockquote>
<p>一般的，样本数≥30即可称为大样本。 大样本条件下，抽样平均数的分布接近正态分布。</p>
<p>但必要抽样数目的确定是有相关公式计算的，这里就不给出了，感兴趣的话可以去搜搜看。</p>
</blockquote>
<p>现在我们继续按照课程中的例子进行取样，样本容量为5，不断得取10000次，计算均值的分布情况如下：</p>
<p><img src="https://s1.ax1x.com/2018/09/14/iEcyUx.png" alt="iEcyUx.png"></p>
<p>（完全看不出这是个什么分布）</p>
<p>将样本容量改为50，仍然取10000次，计算均值的分布情况如下：</p>
<p><img src="https://s1.ax1x.com/2018/09/14/iEc656.png" alt="iEc656.png"></p>
<p>已经可以看出正态分布的样子了，那如果继续增加样本容量，改为5000，同样取10000次，计算均值的分布情况如下：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1536915532459.png" alt="1536915532459"></p>
<p>想比上一幅图，这幅可视化更接近正态分布，均值处于相同的位置，但方差（离散程度）明显小了很多。</p>
<p>上面的这个过程就是<strong>中心极限定理</strong>的含义，随着样本容量的逐渐增大，平均数的抽样分布越接近正态分布（但也不一定必须要很大很大才能近似于正态分布），同样这也适用于求和，比例等，但<strong>不适用于所有的统计量</strong>，比如说最大值，方差等等。</p>
<p><strong>中心极限定理的妙处就在于，我们可以从任意的乱七八糟的分布取任意数量的样本值（比如上面例子中的5,50），然后计算样本的均值（或者和），不断得取值求均，最终做他们频率的可视化，你会发现这是一个非常完美的正态分布。</strong></p>
<p>现实生活中有很多的随机过程，有的分布就是乱七八糟，但是你可以通过中心极限定理，得到他们均值或者和的正态分布，这也是为什么正态分布在统计中如此常用的原因之一。</p>
<blockquote>
<p>如果感觉理解起来还是有点儿困难的话，你可以戳<a href="http://onlinestatbook.com/stat_sim/sampling_dist/" target="_blank" rel="noopener">在线抽样分布模拟器</a>，自己动手试一试。</p>
</blockquote>
<h2 id="大数定理"><a href="#大数定理" class="headerlink" title="大数定理"></a>大数定理</h2><p>大数定理表达的是<strong>随着样本容量增加，样本平均数越来越接近总体平均数</strong>，字面上的意思很好理解，但这里有一点要注意，我们举例来说明一下：</p>
<p>比如说，我现在有100枚硬币，放在一个盒子里，随便摇一下盒子，打开，对正面朝上的硬币进行计数（当然，我们知道期望为100 x 0.5 = 50）：</p>
<p>第一次实验的结果是55；第二次是60；第三次是70，三次实验的均值为（(55+60+70)/3 ≈62），那你觉得，下次实验的结果是更有可能小于50还是大于50呢？</p>
<p>你有可能这样想，根据大数定理，随着我们试验次数的不断增加，均值肯定是不断趋向于50的，前三次的实验中每次都超过50，那么下次的实验会有更大的可能小于50，来纠正前三次实验的偏差。</p>
<p>如果你真的这样想，你就陷入了<strong>赌徒悖论</strong>。大数定理不关心前面发生的有限次实验，因为后面还有无限次的实验，而这无限次实验的期望值是50。这个例子可能比较随意，但这就是大数定理的含义。</p>
<h2 id="自助法"><a href="#自助法" class="headerlink" title="自助法"></a>自助法</h2><p>自助法，bootstrap，也就是重复抽样。还记得上一节导学中讲到的numpy.random.choice函数吗？里面有一个<em>replace</em>参数，默认为True表示重复取样，也就是自助法；若设置为False，则表示不重复取样。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本期导学主要对描述统计学和概率的基础知识进行了总结，这部分偏理论一些，如果觉得理解起来有点吃力，可以通过重复看视频，边看边用笔去算或者去网上搜集一些资料或者找一些教科书去查阅，要求是：不一定要完全掌握其原理，但求理解和会用。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/09/2018-9-9-第九周-P3阶段总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/09/09/2018-9-9-第九周-P3阶段总结/" class="post-title-link" itemprop="url">每周导学-第九周-P3阶段总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-09 12:30:09" itemprop="dateCreated datePublished" datetime="2018-09-09T12:30:09+08:00">2018-09-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 12:51:55" itemprop="dateModified" datetime="2019-04-03T12:51:55+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DAND-VIP/" itemprop="url" rel="index"><span itemprop="name">DAND-VIP</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/09/09/2018-9-9-第九周-P3阶段总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/09/09/2018-9-9-第九周-P3阶段总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Nothing is particularly hard if you divide it into small jobs.</p>
</blockquote>
<p>Hi，同学们，本周是我们P3阶段的最后一周，前三周我们掌握了数据分析的基本流程、Pandas在数据分析各个流程中的基本应用，使用matplotlib&amp;Pandas进行可视化的技巧，并且在项目三中得到了巩固和锻炼。我也陆续收到了大家的项目展示，都十分厉害，尤其是问题的提出以及可视化，非常能吸引人，只是数据整理阶段的代码还需再慢慢磨练，得以精简。本周导学呢，我们就是对之前所学做一个总结，希望大家也能自己做一份总结（这份总结才是最贴切你自己需求的），优达日的时候我们会一起交流一下自己的项目心得以及踩过的坑，等你们哦~</p>
<p><strong>项目三(P3)阶段</strong>总共包含<strong>四周</strong>，在这一个月内，我们要对<strong>数据分析入门</strong>进行学习，学习数据分析思维，掌握Python数据分析及可视化方法，并使用所学知识完成<strong>项目三：探索数据集</strong>，尝试着自己完成整个数据分析的流程，得到一些饶有兴趣的结论，你一定会非常有成就感哒！那么以下便是这四周的学习安排：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>学习重点</th>
<th>对应课程</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1周</td>
<td>数据分析过程-1</td>
<td>数据分析过程&amp;案例研究-1</td>
</tr>
<tr>
<td>第2周</td>
<td>数据分析过程-2</td>
<td>案例研究-1&amp;案例研究-2</td>
</tr>
<tr>
<td>第3周</td>
<td>完成项目</td>
<td>项目：探索数据集</td>
</tr>
<tr>
<td><strong>第4周</strong></td>
<td><strong>项目修改与通过</strong></td>
<td><strong>修改项目、查缺补漏、休息调整</strong></td>
</tr>
</tbody>
</table>
<font size="3" color="red">！！看这里！！：在P3课程里面安排了SQL的高阶课程，但是因为在项目三中并不会涉及到SQL知识，所以为了保证大家学习的连贯性，在完成前两周的课程之后，就开始项目。至于！！SQL的高阶知识，大家可以放在课程通关后进行选修！！； </font>

<p>本阶段可能是个挑战，请一定要<strong>保持自信</strong>，请一定要坚持<strong>学习和总结</strong>，如果遇到任何<strong>课程问题</strong>请参照如下顺序进行解决：</p>
<ul>
<li>先自行查找问题答案（注意提取关键词），参考：谷歌/百度搜索、<a href="http://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>、<a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a>、<a href="https://stackoverflow.com/" target="_blank" rel="noopener">stack<strong>overflow</strong></a>、<a href="https://github.com/CapAllen/DAND_VIP_Class/blob/master/%E6%8B%93%E5%B1%95%E5%8F%82%E8%80%83/Python%20for%20Data%20Analysis%2C%202nd%20Edition.pdf" target="_blank" rel="noopener"><strong>Python for Data Analysis, 2nd Edition</strong> </a>、<a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Python Cookbook</a></li>
<li>若问题未解决，请将<strong>问题</strong>及其<strong>所在课程章节</strong>发送至微信群，并@助教即可</li>
</ul>
<p>饭要一口一口吃，路要一步一步走，大家不要被任务吓到，跟着导学一步一步来，肯定没问题哒！那我们开始吧！</p>
<blockquote>
<p><strong>注：</strong>本着<strong>按需知情</strong>原则，所涉及的知识点都是在数据分析过程中必须的、常用的，而不是最全面的，想要更丰富，那就需要你们课下再进一步的学习和探索！</p>
</blockquote>
<h1 id="本周目标"><a href="#本周目标" class="headerlink" title="本周目标"></a>本周目标</h1><ul>
<li>完成你的项目，并且对P3阶段做一个自我总结，最好能以博客或者朋友圈文章的形式进行输出。</li>
</ul>
<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><table>
<thead>
<tr>
<th>时间</th>
<th>学习资源</th>
<th>学习内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>周二</td>
<td>微信群 - 每周导学</td>
<td>预览每周导学</td>
</tr>
<tr>
<td>周三、周四</td>
<td>Udacity - Classroom</td>
<td>项目三</td>
</tr>
<tr>
<td>周五</td>
<td>微信/Classin - 1V1</td>
<td>课程难点</td>
</tr>
<tr>
<td>周六</td>
<td>Classin - 优达日</td>
<td>本周学习总结、答疑</td>
</tr>
<tr>
<td>周日</td>
<td>笔记本</td>
<td>总结沉淀</td>
</tr>
<tr>
<td>周一</td>
<td>自主学习</td>
<td>查漏补缺</td>
</tr>
</tbody>
</table>
<h1 id="知识点清单"><a href="#知识点清单" class="headerlink" title="知识点清单"></a>知识点清单</h1><h2 id="第六周-数据分析过程"><a href="#第六周-数据分析过程" class="headerlink" title="第六周-数据分析过程"></a><a href="http://www.capallen.top/dand-vip/2018/08/19/%E7%AC%AC%E5%85%AD%E5%91%A8-1-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">第六周-数据分析过程</a></h2><ul>
<li><p>数据分析的基本流程</p>
<ul>
<li>提出问题</li>
<li>整理数据（收集、评估、清理）</li>
<li>探索性数据分析</li>
<li>得出结论，传达结果</li>
</ul>
</li>
<li><p>Pandas在数据分析中的应用</p>
<ul>
<li>导入文件（read_csv/excel/sep/encoding）</li>
<li>数据评估（shape / info / describe / columns/ isnull/ duplicated/ value_counts/ sort_values/ ascending/ unique/ nunique）</li>
<li>数据筛选（df[‘col_name’]/loc/iloc/np.r_/isin/query/groupby/<code>&amp;</code>/<code>|</code>）</li>
<li>数据清理（drop/inplace/fillna/dropna/drop_duplicates/rename/replace）</li>
<li>数据融合（merge/concat/append/join）</li>
<li>可视化（plot）</li>
<li>导出数据（to_csv/index/encoding = ‘utf-8-sig’）</li>
</ul>
</li>
</ul>
<h2 id="第七周-可视化"><a href="#第七周-可视化" class="headerlink" title="第七周-可视化"></a><a href="http://www.capallen.top/dand-vip/2018/08/28/%E7%AC%AC%E4%B8%83%E5%91%A8-%E5%8F%AF%E8%A7%86%E5%8C%96/" target="_blank" rel="noopener">第七周-可视化</a></h2><ul>
<li><p>基本概念（fig/ax）</p>
</li>
<li><p>开始绘图（plt.subplots/plt.add_subplot/plt.figure）</p>
</li>
<li><p>坐标轴设置</p>
<ul>
<li>调整范围（ax.axis/xlim/ylim）</li>
<li><p>调整刻度</p>
<ul>
<li>设置间隔（locator_params）</li>
<li>设置顺序，角度（xticks(order_list,tick_names,rotation)</li>
</ul>
</li>
<li><p>双轴（twinx）</p>
</li>
</ul>
</li>
<li><p>标题与轴标题（title,xlabel,ylabel）</p>
</li>
<li><p>图例（legend）</p>
</li>
<li><p>颜色与样式（plot(x,y,’<code>color`</code>marker<code></code>line`’）</p>
</li>
<li><p>网格（grid）</p>
</li>
<li><p>图像注释（annote）</p>
</li>
<li><p>平行于坐标轴的线（vline/hline）</p>
</li>
<li><p>常用可视化图形</p>
<ul>
<li>散点图（scatter）</li>
<li>条形图（bar/barh）</li>
<li>直方图（hist）</li>
<li>饼状图（pie）</li>
<li>箱线图（box）</li>
</ul>
</li>
</ul>
<h2 id="第八周-TMDb数据分析"><a href="#第八周-TMDb数据分析" class="headerlink" title="第八周-TMDb数据分析"></a><a href="http://www.capallen.top/dand-vip/2018/09/05/%E7%AC%AC%E5%85%AB%E5%91%A8-TMDB%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">第八周-TMDb数据分析</a></h2><ul>
<li>如何提出问题？ 找出关键变量，提与之相关的问题</li>
<li>数据备份（copy）</li>
<li>如何将一列处理为多列？（<a href="http://www.capallen.top/dand-vip/2018/09/05/%E7%AC%AC%E5%85%AB%E5%91%A8-TMDB%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/#%E6%B8%85%E7%90%86%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener">genres列的处理</a>）<ul>
<li>拓展：pivot函数</li>
</ul>
</li>
</ul>
<p><img src="https://pandas.pydata.org/pandas-docs/stable/_images/reshaping_pivot.png" alt></p>
<ul>
<li><p>如何着手探索性数据分析？</p>
<ul>
<li>单变量 - 双变量 - 多变量</li>
<li>关键变量 - 其他变量与关键变量</li>
</ul>
</li>
<li><p>可视化</p>
<ul>
<li>热度图（heatmap）</li>
<li>pairplot</li>
</ul>
</li>
<li>一些函数：<ul>
<li>获取某一位置的数值 quantile</li>
<li>按列表筛选 isin</li>
</ul>
</li>
</ul>
<h2 id="第八周-FBI枪支数据分析"><a href="#第八周-FBI枪支数据分析" class="headerlink" title="第八周-FBI枪支数据分析"></a><a href="http://www.capallen.top/dand-vip/2018/09/08/%E7%AC%AC%E5%85%AB%E5%91%A8-FBI%E6%9E%AA%E6%94%AF%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">第八周-FBI枪支数据分析</a></h2><ul>
<li>DataFrame行列变换：transpose</li>
<li>按字符串内容筛选：contains</li>
<li>按索引进行数据融合：join</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这四周的学习，你又掌握了：</p>
<ul>
<li>数据分析的基本流程</li>
<li>Pandas在数据分析各个流程中的基本应用</li>
<li>Pandas常用函数的用法</li>
<li>Matplotlib在可视化中的应用</li>
</ul>
<p>此外，你还增长了这些软技能：</p>
<ul>
<li>数据分析思维（化繁为简、化难为易、关键信息的提取）</li>
<li>耐心（EDA的过程，做过的都知道）</li>
<li>细心（有没有调试半天最终才发现是自己马虎导致的问题？）</li>
</ul>
<p>如果你学习时间充裕，你还有可能掌握了：</p>
<ul>
<li>Seaborn在可视化中的应用</li>
<li>如何快速有效地使用搜索引擎</li>
<li>在Stackoverflow注册账户，提出问题，成为一名铜牌用户</li>
<li>有了自己的技术博客，并发表了第一篇总结性文章</li>
<li>… …</li>
</ul>
<p>哈！这么总结下来，发现不知不觉间，又掌握了很多！又进步了很多！我导师之前教育我说：“<strong>你之所以现在这么焦虑，都是因为你自己的能力满足不了你的欲望。</strong>”那么，同样因为对未来感到焦虑来到这里学习的你们，经过这段时间的学习，焦虑是不是缓解了许多呢？哈哈，所以，请不要放松脚步，KEEP GOING！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-fas fa-space-shuttle"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: true,
    notify: true,
    appId: '1GIsNa4yl3cJmXFEcFxWgNJX-gzGzoHsz',
    appKey: 'sAf2Iz8P4JMH7Ac7YKeoojii',
    placeholder: '畅所欲言吧，朋友！',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
</script>





  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?bd2294fafea3389ee458f1d9be5a2157"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
